# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

## Chat Page Streaming Conversion Pattern

### Overview
Comprehensive documentation untuk mengkonversi legacy chat page components menjadi modern streaming implementation dengan real-time animations. Pattern ini berdasarkan successful conversion dari KUHAPChatPage.tsx yang mencakup streaming events, animations, auto-focus management, dan storage optimization.

### 1. Service Layer Conversion

#### Legacy Service Pattern (Manual Event Handling):
```typescript
// ‚ùå OLD: Manual event handling dengan sendStreamingChatMessage
const result = await sendStreamingChatMessage(
  userMessageContent, 
  selectedFiles,
  (event) => {
    // Manual event handling
    switch (event.event) {
      case RunEvent.RunStarted:
        setStreamingStatus({ isThinking: true });
        break;
      // ... manual event handling
    }
  }
);
```

#### Modern Service Pattern (useAIChatStreamHandler):
```typescript
// ‚úÖ NEW: Modern hook-based streaming
const { handleStreamResponse } = useAIChatStreamHandler();

const handleSendMessage = async () => {
  // Clear input immediately
  setInputMessage('');
  
  try {
    // Use modern streaming handler with agent ID
    await handleStreamResponse(
      userMessageContent,
      selectedFiles.length > 0 ? selectedFiles : undefined,
      'agent-id' // Agent ID for proper routing
    );
    
    // Reset files after successful send
    setSelectedFiles([]);
    setFileValidationErrors([]);
  } catch (error) {
    console.error('Error sending message:', error);
    setSelectedFiles([]);
  }
};
```

### 2. Component Architecture Update

#### Required Imports:
```typescript
import React, { useState, useRef, useEffect } from 'react';
import { PlaygroundChatMessage } from '@/types/playground';
import { usePlaygroundStore } from '@/stores/PlaygroundStore';
import StreamingStatus from '@/hooks/streaming/StreamingStatus';
import useAIChatStreamHandler from '@/hooks/playground/useAIChatStreamHandler';
import { formatMessage } from '@/utils/markdownFormatter';
import { getStorageStats, forceCleanup } from '@/stores/PlaygroundStore';
```

#### Store Integration Pattern:
```typescript
const ComponentChatPage: React.FC<ComponentChatPageProps> = ({ onBack }) => {
  // Use modern streaming hooks and store
  const { 
    messages, 
    isStreaming: isLoading, 
    streamingStatus, 
    currentChunk, 
    setMessages, 
    resetStreamingStatus 
  } = usePlaygroundStore();
  
  // Use modern streaming handler
  const { handleStreamResponse } = useAIChatStreamHandler();
  
  // Component state
  const [inputMessage, setInputMessage] = useState('');
  const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
  const [fileValidationErrors, setFileValidationErrors] = useState<string[]>([]);
  
  // Refs for UI management
  const textareaRef = useRef<HTMLTextAreaElement>(null);
- **Monochromatic Design Principles**: For professional applications like law enforcement tools, use sophisticated gray-based palette with minimal accent colors instead of rainbow-colored UI elements
- **Strategic Color Assignment**:
  * Gray-600/gray-700: Default states, thinking, memory operations (neutral activities)
  * Blue-600/blue-500: Active tool calls, knowledge access, content processing (active operations)
  * Green-600: Only for completion status (success state)
  * Red-500/red-600: Only for actual errors (error state)
  * Avoid: purple, indigo, emerald, orange, pink for professional applications
- **Consistent Text Colors**: Use gray-700 for all status text to maintain readability and visual hierarchy
- **Background Consistency**: Use gray-50 backgrounds with border-gray-200 for all information containers
- **Subtle Visual Enhancement**: 
  * Add backdrop-blur-sm for modern glass effect
  * Use shadow-sm for subtle depth without overwhelming design
  * Apply transparency (gray-50/80, border-gray-200/60) for sophisticated layering
- **Animation Color Coordination**: 
  * Use gray-400/gray-500 for neutral animations (thinking dots, memory bars)
  * Use blue-400/blue-500 for active operation animations (tool calls, processing)
  * Maintain consistent color language across all animated elements
- **Professional UI Standards**:
  * Reduced visual noise while maintaining engaging animations
  * Better accessibility through consistent contrast ratios
  * Cohesive design that aligns with enterprise software standards
  * Visual hierarchy that guides user attention without overwhelming

## Instructions for Using Graphiti's MCP Tools for Agent Memory

### Before Starting Any Task

- **Always search first:** Use the `search_nodes` tool to look for relevant preferences and procedures before beginning work.
- **Search for facts too:** Use the `search_facts` tool to discover relationships and factual information that may be relevant to your task.
- **Filter by entity type:** Specify `Preference`, `Procedure`, or `Requirement` in your node search to get targeted results.
- **Review all matches:** Carefully examine any preferences, procedures, or facts that match your current task.

### Always Save New or Updated Information

- **Capture requirements and preferences immediately:** When a user expresses a requirement or preference, use `add_episode` to store it right away.
  - _Best practice:_ Split very long requirements into shorter, logical chunks.
- **Be explicit if something is an update to existing knowledge.** Only add what's changed or new to the graph.
- **Document procedures clearly:** When you discover how a user wants things done, record it as a procedure.
- **Record factual relationships:** When you learn about connections between entities, store these as facts.
- **Be specific with categories:** Label preferences and procedures with clear categories for better retrieval later.

### During Your Work

- **Respect discovered preferences:** Align your work with any preferences you've found.
- **Follow procedures exactly:** If you find a procedure for your current task, follow it step by step.
- **Apply relevant facts:** Use factual information to inform your decisions and recommendations.
- **Stay consistent:** Maintain consistency with previously identified preferences, procedures, and facts.

### Best Practices

- **Search before suggesting:** Always check if there's established knowledge before making recommendations.
- **Combine node and fact searches:** For complex tasks, search both nodes and facts to build a complete picture.
- **Use `center_node_uuid`:** When exploring related information, center your search around a specific node.
- **Prioritize specific matches:** More specific information takes precedence over general information.
- **Be proactive:** If you notice patterns in user behavior, consider storing them as preferences or procedures.

**Remember:** The knowledge graph is your memory. Use it consistently to provide personalized assistance that respects the user's established preferences, procedures, and factual context.

## Gemini API Prompt Engineering Lessons

- **Menghilangkan Frasa Berulang di Respons Gemini**: Untuk menghindari frasa seperti "Baik, saya akan menyusun laporan..." yang selalu muncul di awal respons:
  * Hindari instruksi eksplisit seperti "Gunakan kemampuan pencarian web Anda untuk mengumpulkan informasi..."
  * Jangan gunakan frasa "Setelah itu, buatlah laporan..." yang menyebabkan model memberikan konfirmasi
  * Gunakan instruksi langsung seperti "Susun laporan..." atau "Identifikasi dan sajikan..."
  * Hindari kata "HARUS" atau "Anda HARUS" yang memicu respons konfirmasi
  * Struktur prompt dengan role definition yang langsung ke tugas tanpa instruksi bertahap
  * Contoh yang baik: "Anda adalah analis intelijen yang bertugas menyusun laporan..." (langsung ke tugas)
  * Contoh yang buruk: "Gunakan kemampuan pencarian web Anda untuk mengumpulkan informasi... Setelah itu, buatlah laporan..." (memicu konfirmasi)

- **Gemini 2.0 Grounding Implementation**: Untuk implementasi grounding yang benar dengan Gemini 2.0:
  * Gunakan struktur API call yang benar: `contents: [{ parts: requestParts }]` bukan `contents: { parts: requestParts }`
  * Akses grounding metadata dengan: `response.candidates?.[0]?.groundingMetadata`
  * Grounding chunks tersedia di: `groundingMetadata?.groundingChunks`
  * Setiap chunk memiliki struktur: `chunk.web?.uri` dan `chunk.web?.title`
  * Gunakan Map untuk deduplikasi sources berdasarkan URI
  * Tambahkan logging untuk debugging: console.log jumlah chunks dan domains yang ditemukan
  * Jika tidak ada sources yang ditemukan, log warning untuk debugging
  * Search entry point tersedia di: `groundingMetadata?.searchEntryPoint`
  * Referensi: https://ai.google.dev/gemini-api/docs/grounding?lang=javascript

- **Gemini Document Processing Implementation**: Untuk implementasi document processing yang benar dengan Gemini API:
  * **File Size Limits**: Maksimal 20MB untuk inline data upload, gunakan File API untuk file > 20MB
  * **Supported MIME Types**: application/pdf, text/plain, text/html, text/css, text/md, text/csv, text/xml, text/rtf, application/x-javascript, text/javascript, application/x-python, text/x-python, plus Office formats (.docx, .xlsx)
  * **Content Structure**: Gunakan format `contents: [{ parts: contentParts }]` dengan text prompt sebelum file untuk hasil optimal
  * **File Processing**: Implement proper base64 encoding dengan validasi MIME type dan file size
  * **Error Handling**: Tambahkan validasi file size, MIME type, dan detailed error messages untuk troubleshooting
  * **Temperature Setting**: Gunakan temperature 0.1 untuk analisis dokumen yang konsisten
  * **Logging Strategy**: Log file details (name, type, size), processing steps, dan API call parameters untuk debugging
  * **UI Integration**: Update accept attribute untuk mendukung semua format yang didukung API
  * **Best Practices**: Text prompt ditempatkan sebelum file attachment, implement comprehensive file validation
  * Referensi: https://ai.google.dev/gemini-api/docs/document-processing?lang=node

## ReactMarkdown Integration Lessons

- **Use inline component definitions**: Define components directly in the components prop for better type safety
- **Component format example**:
  ```typescript
  components={{
    h1: ({ children, ...props }) => (
      <h1 className="text-2xl font-bold" {...props}>
        {children}
      </h1>
    ),
    // other components...
  }}
  ```
- **Error prevention**: "Element type is invalid" errors typically occur when passing objects instead of React components
- **Debugging tip**: If ReactMarkdown fails, check that all component values are actual React component functions
- **Avoid helper functions**: ReactMarkdown components prop expects actual React components, not objects or helper function results

## Authentication & Session Management Lessons

### Logout Functionality in Protected Pages

- **Problem**: Tombol logout di PendingApproval.tsx tidak berfungsi karena state cleanup tidak sempurna
- **Root Cause**: 
  * AuthContext logout function tidak mengupdate currentUser state dengan cepat
  * Storage cleanup tidak comprehensive 
  * Redirect logic bergantung pada auth state changes yang mungkin delayed
- **Comprehensive Solution**:
  ```typescript
  // 1. Monitor currentUser state changes untuk auto-redirect
  useEffect(() => {
    if (!currentUser && !isLoggingOut) {
      navigate('/login', { replace: true });
    }
  }, [currentUser, isLoggingOut, navigate]);

  // 2. Force cleanup semua storage
  const clearAllStorages = () => {
    const keysToRemove = [];
    for (let i = 0; i < localStorage.length; i++) {
      const key = localStorage.key(i);
      if (key && (key.startsWith('supabase.') || key.startsWith('wassidik_') || 
                  key.startsWith('tipidter_') || key.includes('session') || 
                  key.includes('auth'))) {
        keysToRemove.push(key);
      }
    }
    keysToRemove.forEach(key => localStorage.removeItem(key));
    sessionStorage.clear();
  };

  // 3. Multiple fallback redirect strategies
  // Strategy 1: React Router navigate
  setTimeout(() => navigate('/login', { replace: true }), 500);
  // Strategy 2: Window location fallback
  setTimeout(() => window.location.href = '/login', 1500);
  // Strategy 3: Hard refresh last resort
  setTimeout(() => window.location.reload(), 3000);
  ```
- **Key Improvements**:
  * **Auto-redirect monitoring**: useEffect yang monitor currentUser changes
  * **Comprehensive storage cleanup**: Clear semua auth-related localStorage/sessionStorage
  * **Tiered redirect approach**: Multiple fallback strategies untuk ensure redirect success
  * **Better error handling**: Proper error state management dengan user feedback
  * **Loading states**: Clear visual feedback selama logout process
- **Best Practices**:
  * Selalu implement multiple redirect strategies untuk handle edge cases
  * Force cleanup storage untuk memastikan session benar-benar clear
  * Monitor auth state changes dengan useEffect untuk auto-redirect
  * Provide clear loading dan error states untuk better UX
  * Add comprehensive logging untuk debugging session issues

## API Integration Lessons

- When using FormData for file uploads, don't set Content-Type header manually - let browser handle it
- For api.reserse.id, always use VITE_API_KEY in X-API-Key header
- For flow.reserse.id, use VITE_PERKABA_API_KEY
- Set appropriate file size limits (50MB) for image uploads in nginx and vite config
- Use relative URLs with proxy in vite.config.ts instead of absolute URLs
- Add all required domains to allowedHosts in vite.config.ts (api.reserse.id, flow.reserse.id, app.reserse.id)
- Configure allowedHosts in both server and preview mode
- Use wildcard subdomain (.reserse.id) for broader access
- Set proper hostname in docker and nginx configs

### Service Implementation Best Practices

- **NEVER hardcode API endpoints**: Always use `env.apiUrl` atau `API_BASE_URL` dari config
- **Follow existing patterns**: Gunakan pola yang sama dengan service yang sudah ada (seperti tipidkorService.ts)
- **Import env config**: Selalu import `{ env } from '@/config/env'` untuk akses ke environment variables
- **Use consistent structure**: 
  ```typescript
  const API_BASE_URL = env.apiUrl || 'https://api.reserse.id';
  const url = `${API_BASE_URL}/v1/playground/teams/[team-name]/runs`;
  ```
- **Session management**: Implementasi session dan user ID management yang konsisten dengan Supabase auth
- **Error handling**: Gunakan retry logic dan network error detection yang sama
- **Response parsing**: Implementasi parseResponse function untuk handle berbagai format response
- **Timeout handling**: Gunakan FETCH_TIMEOUT yang konsisten (600000ms = 10 menit)
- **Headers consistency**: Gunakan pattern header yang sama (Accept, X-API-Key, X-User-ID, Authorization)
- **API Key Security**: Selalu gunakan `import.meta.env.VITE_API_KEY` dari environment variables, NEVER hardcode API keys

## PenyidikAi Agent Implementation Pattern

Untuk menambahkan agen baru di PenyidikAi.tsx, ikuti langkah-langkah berikut:

1. Buat Service File (src/services/[agentName]Service.ts):
   - Import env dan uuid
   - Gunakan FormData untuk request body
   - Implementasikan retry logic untuk error jaringan dan server
   - Gunakan endpoint `/v1/playground/agents/[endpoint-name]/runs`
   - Implementasikan fungsi sendChatMessage, clearChatHistory, dan initializeSession
   - Contoh:
   ```typescript
   const formData = new FormData();
   formData.append('message', message.trim());
   formData.append('agent_id', 'fismondev-chat');
   formData.append('stream', 'false');
   formData.append('monitor', 'false');
   formData.append('session_id', currentSessionId);
   formData.append('user_id', currentSessionId);
   ```

2. Buat Konfigurasi Agen (src/data/agents/[agentName]Agent.ts):
   - Gunakan interface ExtendedAgent
   - Tentukan id, name, type, status, dan description
   - Tambahkan icon dan iconClassName
   - Contoh:
   ```typescript
   export const fismondevAgent: ExtendedAgent = {
     id: 'fismondev_001',
     name: 'Fismondev AI',
     type: 'fismondev_chat',
     status: 'on',
     description: 'Asisten AI yang fokus pada tindak pidana di bidang Fiskal, Moneter, dan Devisa',
     icon: DollarSign,
     iconClassName: 'text-green-600',
     fields: []
   };
   ```

3. Update Types (src/types/index.ts):
   - Tambahkan tipe agen baru ke union type AgentType
   - Contoh: `| 'fismondev_chat'`

4. Update Utils (src/utils/utils.ts):
   - Tambahkan ID agen ke AGENT_IDS
   - Tambahkan case di getAgentTypeFromId
   - Contoh:
   ```typescript
   FISMONDEV_CHAT: 'fismondev_001'
   ```

5. Update AgentCard (src/components/AgentCard.tsx):
   - Tambahkan case di getAgentIcon
   - Gunakan ikon yang sesuai
   - Contoh:
   ```typescript
   case 'fismondev_chat':
     return <img src="/img/krimsus.png" alt="Fismondev AI" className="h-10 w-10" />;
   ```

6. Update PenyidikAi Component (src/pages/PenyidikAi.tsx):
   - Import agen dan service
   - Tambahkan agen ke array agents
   - Tambahkan case di renderContent
   - Tambahkan styling yang sesuai
   - Contoh:
   ```typescript
   case 'fismondev_chat':
     return <ChatInterface sendMessage={sendFismondevChatMessage} />;
   ```

7. Styling Konsisten:
   - Gunakan gradient yang sesuai dengan jenis agen
   - Pertahankan konsistensi visual dengan agen lain
   - Contoh:
   ```typescript
   agent.type === 'fismondev_chat'
     ? "bg-gradient-to-br from-green-50 to-emerald-50 hover:from-green-100 hover:to-emerald-100"
     : "bg-gradient-to-br from-purple-50 to-indigo-50 hover:from-purple-100 hover:to-indigo-100"
   ```

## Security Lessons

- Add rate limiting in nginx (10r/s with burst 20)
- Block unnecessary paths (/webui, /geoserver, /admin, etc.)
- Add security headers (X-Frame-Options, X-Content-Type-Options, X-XSS-Protection)
- Configure robots.txt to disallow all
- Handle favicon.ico and .git requests properly
- Filter proxy paths in vite.config.ts to only allow needed routes

## Project Structure Lessons

From project.md:
- Follow consistent service pattern for new agents:
  - Service file in src/services/
  - Agent config in src/data/agents/
  - Page component in src/pages/
  - Update Sidebar.tsx and App.tsx
- Use existing components:
  - ChatInterface for chat functionality
  - AgentCard for agent display
  - BaseAgentForm for forms
- Maintain consistent styling with Tailwind CSS
- Handle chat message formatting:
  - Use flex-wrap and min-w-0 to prevent overflow
  - Add pre-wrap for code blocks and pre elements
  - Make tables scrollable horizontally
  - Use word-break and overflow-wrap for long content
- Agent configuration best practices:
  - Add descriptive icons that match agent functionality
  - Use consistent color schemes for related agents
  - Keep form heights appropriate for expected input length
  - Include clear placeholder text in form fields

## Chat Agent Implementation Pattern

When adding a new chat-based agent to the UndangUndang component, follow these steps:

1. Create Service File (src/services/[agentName]Service.ts):
 - Import env config and uuid
 - Configure API constants (API_KEY, MAX_RETRIES, etc.)
 - Implement session management
 - Implement parseResponse function for handling responses
 - Implement sendChatMessage with FormData and proper error handling
 - Add clearChatHistory and initializeSession functions

2. Update Types (src/types/index.ts):
 - Add new agent type to AgentType union (e.g., 'ciptakerja_chat')

3. Update Utils (src/utils/utils.ts):
 - Add agent ID to AGENT_IDS constant
 - Add case in getAgentTypeFromId
 - Don't add to getTypeDisplay if it's a chat agent (these use custom display names)

4. Update Agent Card (src/components/AgentCard.tsx):
 - Add case in getAgentIcon with appropriate Lucide icon
 - Choose an icon that represents the agent's function
 - Use consistent icon size (24px)
 - Give icon an appropriate color

5. Update UndangUndang Component (src/pages/UndangUndang.tsx):
 - Import new service's sendChatMessage
 - Add agent to agents array with proper configuration
 - Add case in renderContent switch statement
 - Configure card styling:
   * Use professional color gradients
   * Maintain visual hierarchy
   * Ensure contrast and readability
   * Keep consistent hover effects
   * Match icon and colors to agent's purpose

6. Follow Best Practices:
 - Maintain consistent error handling
 - Use proper session management
 - Implement proper logging
 - Follow API security guidelines
 - Use professional color schemes appropriate for police applications
 - Ensure visual consistency with existing agents

Professional Color Scheme Examples:
- Financial Services (P2SK): blue-indigo gradient (from-blue-50 to-indigo-50)
- Criminal Law (KUHP): rose-orange gradient (from-rose-50 to-orange-50)
- Technology Law (ITE): cyan-sky gradient (from-cyan-50 to-sky-50)
- Labor Law (Cipta Kerja): slate-gray gradient (from-slate-50 to-gray-50)

## Environment Configuration Lessons

- Use default values in env.ts for critical variables
- Keep API keys secure and never log them
- Use separate keys for different services:
  - VITE_API_KEY for api.reserse.id
  - VITE_PERKABA_API_KEY for flow.reserse.id
  - VITE_OPENAI_API_KEY for OpenAI
  - VITE_GEMINI_API_KEY for Google Gemini API (sentiment analysis)
  - VITE_SUPABASE_URL for Supabase URL
  - VITE_SUPABASE_ANON_KEY for Supabase Anon Key
  - etc.

## Supabase Security Lessons

‚ö†Ô∏è **CRITICAL SECURITY PRACTICES:**
- **ALWAYS enable Row Level Security (RLS)** pada semua tabel public
- **NEVER expose auth.users** melalui views atau materialized views
- **ALWAYS create proper RLS policies** untuk data isolation
- **REVOKE anonymous access** dari tabel yang mengandung data user
- **GRANT access hanya untuk authenticated users** sesuai kebutuhan

### Critical Column Names in auth.users:
- **‚úÖ CORRECT**: Use `raw_user_meta_data` for user metadata storage
- **‚ùå WRONG**: Using `user_metadata` (this column does not exist in auth.users)
- **‚úÖ CORRECT**: Use `raw_app_meta_data` for app metadata storage
- **Note**: Always check actual column names in auth.users table as they may differ from documentation

### Security Implementation Pattern:
```sql
-- 1. Enable RLS untuk tabel baru
ALTER TABLE public.table_name ENABLE ROW LEVEL SECURITY;

-- 2. Buat policy untuk user isolation
CREATE POLICY "Users can only access their own data" 
ON public.table_name 
FOR ALL 
USING (auth.uid()::text = user_id);

-- 3. Revoke akses anon dan grant authenticated
REVOKE ALL ON public.table_name FROM anon;
GRANT SELECT, INSERT, UPDATE, DELETE ON public.table_name TO authenticated;
```

### Admin Function Implementation:
```sql
-- Update user metadata correctly
UPDATE auth.users 
SET raw_user_meta_data = COALESCE(raw_user_meta_data, '{}'::jsonb) || '{"registration_status": "approved"}'::jsonb
WHERE id = p_user_id;

-- Read user metadata correctly
SELECT raw_user_meta_data->>'registration_status' as registration_status
FROM auth.users WHERE id = user_id;
```

### Application Code Security:
```typescript
// ‚úÖ CORRECT - Selalu filter berdasarkan user
const { data } = await supabase
  .from('table_name')
  .select('*')
  .eq('user_id', user.id);

// ‚úÖ CORRECT - Selalu include user_id dalam insert
const { data } = await supabase
  .from('table_name')
  .insert({ content: 'data', user_id: user.id });

// ‚ùå WRONG - Query tanpa user filter (akan return empty dengan RLS)
const { data } = await supabase.from('table_name').select('*');

// ‚ùå WRONG - Insert tanpa user_id (akan error dengan RLS)
const { data } = await supabase.from('table_name').insert({ content: 'data' });
```

### Security Monitoring:
- **Regular audit** RLS policies dan permissions
- **Monitor Supabase dashboard** untuk security warnings
- **Test user isolation** secara berkala
- **Backup database** sebelum perubahan security
- **Implement rollback plan** untuk emergency situations

### Common RLS Issues:
- `new row violates row-level security policy` ‚Üí Include user_id dalam insert
- `permission denied for table` ‚Üí Check user authentication status
- `empty result set` ‚Üí Verify user_id filter dalam query
- `exposed auth.users` ‚Üí Remove atau secure views yang mengakses auth schema
- `column "user_metadata" does not exist` ‚Üí Use `raw_user_meta_data` instead

### AdminPanel.tsx reject_user Function Fix - COMPLETED ‚úÖ

**Root Cause**: Functions were using incorrect column name `user_metadata` instead of `raw_user_meta_data` in auth.users table.

**Solution**: Fixed all admin functions to use correct metadata column:
- `reject_user(p_user_id)` - Updated to use `raw_user_meta_data`
- `approve_user(p_user_id)` - Updated to use `raw_user_meta_data`
- `get_users_with_status()` - Updated to use `raw_user_meta_data` with proper type casting

**Functions Status**: All admin functions now working correctly with proper error handling and JSON responses.

**Testing**: All functions tested and verified working through MCP Supabase tools.

## Table Rendering Lessons

### Responsive Table Implementation in Chat Components

Untuk menangani tabel yang kompleks dari backend AI dalam komponen chat, gunakan pattern berikut:

1. **Tailwind Arbitrary Values untuk Table Styling**:
   ```typescript
   className="prose prose-sm max-w-none
             [&_table]:border-collapse [&_table]:my-4 [&_table]:w-full [&_table]:min-w-[600px] [&_table]:text-sm [&_table]:bg-white [&_table]:rounded-lg [&_table]:overflow-hidden [&_table]:shadow-sm
             [&_th]:bg-red-50 [&_th]:p-3 [&_th]:border [&_th]:border-gray-300 [&_th]:font-semibold [&_th]:text-left [&_th]:text-red-800 [&_th]:whitespace-nowrap [&_th]:max-w-[200px]
             [&_td]:p-3 [&_td]:border [&_td]:border-gray-300 [&_td]:align-top [&_td]:leading-relaxed [&_td]:break-words [&_td]:hyphens-auto
             [&_td:first-child]:font-semibold [&_td:first-child]:bg-gray-50 [&_td:first-child]:whitespace-nowrap [&_td:first-child]:min-w-[150px] [&_td:first-child]:max-w-[200px]
             [&_td:last-child]:w-auto [&_td:last-child]:max-w-[400px]
             [&_tr:nth-child(even)]:bg-gray-50/50
             [&_tr:hover]:bg-gray-100/50"
   ```

2. **Responsive Wrapper Pattern**:
   ```typescript
   <div className="overflow-x-auto -mx-2 sm:-mx-4">
     <div className="prose..." dangerouslySetInnerHTML={{ __html: formatMessage(content) }} />
   </div>
   ```

3. **Key Styling Principles**:
   - **Minimum Width**: Set `min-w-[600px]` untuk tabel agar tetap readable
   - **Column Control**: Batasi lebar kolom pertama dan terakhir dengan `max-w-[200px]` dan `max-w-[400px]`
   - **Text Wrapping**: Gunakan `break-words` dan `hyphens-auto` untuk text yang panjang
   - **Visual Enhancement**: Tambahkan hover effects, alternating colors, dan shadow
   - **Responsive Scroll**: Gunakan `overflow-x-auto` untuk scroll horizontal pada layar kecil

4. **Benefits**:
   - Tabel tetap readable pada semua ukuran layar
   - Scroll horizontal otomatis pada mobile
   - Professional appearance dengan visual enhancements
   - Consistent dengan design system aplikasi

5. **Common Issues**:
   - **Kolom terlalu lebar**: Gunakan `max-width` constraints
   - **Text overflow**: Implementasikan `break-words` dan `hyphens-auto`
   - **Mobile responsiveness**: Selalu wrap dengan `overflow-x-auto`
   - **CSS conflicts**: Gunakan arbitrary values untuk specificity yang tinggi

## API Key Security Lessons

‚ö†Ô∏è **CRITICAL SECURITY PRACTICES:**
- **NEVER hardcode API keys in source code files**
- **NEVER commit .env files to version control**
- **NEVER log actual API key values, even partially**
- **ALWAYS use environment variables for sensitive credentials**

### Security Patterns:
```typescript
// ‚úÖ CORRECT - Use environment variables
const API_KEY = import.meta.env.VITE_GEMINI_API_KEY;

// ‚úÖ CORRECT - Safe logging
console.log('API Key status:', API_KEY ? 'Available' : 'Missing');

// ‚ùå WRONG - Never expose actual key values
console.log('API Key:', API_KEY); // DANGEROUS!
console.log('API Key prefix:', API_KEY.substring(0, 5)); // STILL DANGEROUS!

// ‚ùå WRONG - Never hardcode keys
const API_KEY = 'AIzaSyBf4_0ll5H7OMs7yAtgXO1LWVAWhOcbJmo'; // NEVER DO THIS!
```

### .gitignore Requirements:
- Ensure `.env` files are in .gitignore
- Ensure `.env.local`, `.env.production.local` etc. are ignored
- Provide `.env.example` with placeholder values for new developers

### Emergency Response for Exposed Keys:
1. **Immediately revoke/regenerate** the exposed API key
2. **Remove key from all files** including documentation and comments
3. **Search entire codebase** for any hardcoded key references
4. **Check git history** and remove exposed keys from commits
5. **Update .env.example** with proper placeholder values
6. **Audit all logging statements** to ensure no key exposure

## Supabase Admin Functions & CORS Lessons

### Problem: AdminPanel.tsx reject_user function failing
**Error Pattern**: 
- 404 Not Found untuk RPC function `reject_user`
- CORS error untuk Edge Functions (apikey header not allowed)
- 403 Forbidden untuk auth admin API

### Root Causes:
1. **Missing RPC Functions**: Database tidak memiliki required RPC functions (approve_user, reject_user, is_admin)
2. **CORS Configuration**: Edge Functions tidak mengizinkan 'apikey' header
3. **Parameter Naming**: Function parameter names tidak sesuai dengan expected signature

### Solutions Implemented:

#### 1. Create Missing RPC Functions:
```sql
-- Parameter names harus menggunakan prefix p_ untuk menghindari konflik
CREATE OR REPLACE FUNCTION reject_user(p_user_id uuid)
RETURNS json
LANGUAGE plpgsql
SECURITY DEFINER
AS $$
DECLARE
  result json;
BEGIN
  UPDATE auth.users 
  SET user_metadata = COALESCE(user_metadata, '{}'::jsonb) || '{"registration_status": "rejected"}'::jsonb
  WHERE id = p_user_id;
  
  IF FOUND THEN
    result := json_build_object('success', true, 'message', 'User rejected successfully');
  ELSE
    result := json_build_object('success', false, 'message', 'User not found');
  END IF;
  
  RETURN result;
END;
$$;
```

#### 2. Fix CORS Headers in Edge Functions:
```typescript
// ‚úÖ CORRECT - Include apikey in allowed headers
if (req.method === 'OPTIONS') {
  return new Response('ok', {
    headers: {
      'Access-Control-Allow-Origin': '*',
      'Access-Control-Allow-Methods': 'POST, OPTIONS',
      'Access-Control-Allow-Headers': 'Content-Type, Authorization, apikey', // Add apikey!
    }
  })
}

// ‚úÖ CORRECT - Add to all response headers
headers: {
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Access-Control-Allow-Headers': 'Content-Type, Authorization, apikey',
}
```

#### 3. Correct RPC Function Calls:
```typescript
// ‚úÖ CORRECT - Use proper parameter names
const { data, error } = await supabase.rpc('reject_user', {
  p_user_id: userId  // Use p_user_id, not user_id
});

const { data, error } = await supabase.rpc('is_admin', {
  p_user_id: currentUser.id  // Use p_user_id, not user_id
});
```

### Migration Files Created:
- `supabase/migrations/20241210000001_create_admin_functions.sql` - Creates all RPC functions and admin table
- `supabase/migrations/20241210000002_add_admin_user.sql` - Adds initial admin user
- `supabase/migrations/README.md` - Comprehensive migration guide

### Security Features:
- **SECURITY DEFINER**: Functions run with elevated privileges untuk access auth.users
- **RLS Policies**: Admin table protected dengan Row Level Security
- **Parameter Validation**: Proper error handling dan return types
- **Permission Grants**: Functions granted only to authenticated users

### Files Modified:
- `supabase/functions/admin/reject-user.ts` - Fixed CORS headers
- `supabase/functions/admin/approve-user.ts` - Fixed CORS headers
- `src/pages/AdminPanel.tsx` - Fixed RPC parameter names

### Best Practices:
- **Function Naming**: Use descriptive names dengan proper prefixes
- **Parameter Naming**: Prefix parameters dengan `p_` untuk clarity
- **CORS Headers**: Always include all required headers in Edge Functions
- **Security**: Use SECURITY DEFINER untuk admin functions yang perlu elevated access
- **Error Handling**: Provide structured JSON responses dengan success/error flags
- **Migration Documentation**: Always include comprehensive README untuk migrations

### Common CORS Issues:
- **Missing apikey header**: Edge Functions must explicitly allow 'apikey' in Access-Control-Allow-Headers
- **Inconsistent headers**: All responses (including errors) must include same CORS headers
- **Preflight handling**: OPTIONS requests must return proper CORS headers

### Testing Checklist:
- [ ] RPC functions created dan accessible
- [ ] CORS headers working untuk Edge Functions
- [ ] Admin user properly configured dalam admins table
- [ ] User approval/rejection flow working end-to-end
- [ ] Error handling working untuk all failure scenarios

## Performance Optimization Lessons

- Use code splitting with manual chunks for vendor, UI, and feature code
- Enable proper caching headers in nginx for static assets
- Configure gzip compression for text-based assets
- Preload critical assets in index.html
- Use resource hints (preconnect) for external APIs
- Optimize build settings in vite.config.ts
- Use immutable cache for versioned assets
- Disable caching for API endpoints while keeping static asset caching
- Use different cache strategies for different content types
- Keep HTTP/2 benefits without affecting API responses

## Docker Deployment Lessons

- Use multi-stage builds to reduce final image size
- Configure proper healthchecks for container monitoring
- Set resource limits to prevent container abuse
- Use nginx:alpine as production base image
- Enable logging rotation to prevent disk space issues
- Configure Docker networks with specific names and gateways
- Clean up unused networks before redeploying
- Use production-specific nginx configuration
- Use npm ci for faster, reliable builds
- Enable nginx caching for static assets
- Configure proper resource limits for production
- Use HTTP/2 for better performance
- Enable brotli compression for better compression ratios

## UI/UX Lessons

- Handle chat interface layout:
  - Use flex-wrap and min-w-0 for message containers to prevent overflow
  - Avoid nested scrollbars by using whitespace-pre-wrap and break-words
  - Use single scrollable container at the top level with proper bottom padding (pb-32)
  - Keep input area fixed at bottom with position: fixed
  - Let content flow naturally with proper word breaking
  - Keep tables and code blocks within container width
  - Use space-y utilities for consistent message spacing
  - Ensure enough bottom padding to prevent content from being hidden under input area

- Responsive Loading Animation Best Practices:
  - **Mobile-first skeleton design**: Gunakan `flex gap-4 w-full max-w-[80%]` untuk container yang responsif
  - **Full-width skeleton bars**: Gunakan variasi width (`w-full`, `w-11/12`, `w-full`) untuk natural skeleton appearance
  - **Flexible layout structure**: Gunakan `flex-1 space-y-2 py-1 w-full` untuk content area yang expandable
  - **Theme consistency in skeletons**: Gunakan warna yang sesuai dengan theme (e.g. `bg-purple-200` untuk purple theme)
  - **Smooth animations**: Selalu gunakan `animate-pulse` untuk skeleton loading effects
  - **Descriptive loading text**: Berikan text yang jelas seperti "Mencari informasi dan merangkum jawaban..."
  - **Icon consistency**: Pertahankan icon/avatar yang sesuai dengan agent theme saat loading
  - **Avoid fixed containers**: Jangan gunakan fixed width containers untuk loading states pada mobile
  - **Pattern consistency**: Ikuti established skeleton patterns dari components yang sudah ada
- Consider different AI response formats:
  - Code blocks
  - Tables
  - Long URLs
  - Formatted text
  - Lists and indentation
- Add chat-message class for consistent styling across components
- Use TypeScript interfaces for better type safety and documentation
- Remove unused imports to improve code cleanliness
- Visual consistency:
  - Use meaningful icons for each agent type
  - Maintain consistent color schemes
  - Adjust form sizes based on expected content
  - Provide clear visual hierarchy
- Agent icon implementation:
  - Icons should be defined in AgentCard.tsx's getAgentIcon function
  - Use Lucide icons consistently across all agents
  - Follow color scheme patterns (e.g., indigo for analytics, blue for research)
  - Keep icon size consistent (24px)
  - Don't define icons in individual agent files
  - Use proper icon that represents agent's function (e.g., BarChart3 for trend analysis)
  - For custom SVG icons:
    * Place SVG files in public/img directory
    * Reference in img src with absolute path from public (e.g., "/img/google-scholar.svg")
    * Keep original SVG colors if they match the design
    * Maintain consistent size with w-6 h-6 classes (24px)
- ChatPage implementation best practices:
  - Use consistent structure across all ChatPage components
  - Follow the same pattern for message handling, formatting, and display
  - Use conditional rendering for UI elements that should appear/disappear based on state
  - Hide example questions after user starts chatting (messages.length > 1)
  - Use proper spacing and layout for different screen sizes
  - Ensure proper sidebar spacing with lg:pl-64 to prevent overlap
  - Use max-w-3xl mx-auto for content centering
  - Implement proper scrolling behavior with requestAnimationFrame
  - Use consistent styling for message bubbles, info panels, and input areas
  - Provide clear visual feedback for user actions (copying, sending messages)
  - Use aria-label attributes for better accessibility
  - Remove unused imports to prevent TypeScript errors
- UndangUndang ChatPage implementation pattern:
  - Create dedicated ChatPage components for each agent type (e.g., KUHPChatPage)
  - Use consistent color schemes that match the agent's domain:
    * KUHP (Criminal Law): rose-600 (red) theme
    * P2SK (Financial Services): blue-600 (blue) theme
    * ITE (Technology Law): cyan-600 (light blue) theme
    * Cipta Kerja (Labor Law): slate-600 (gray) theme
    * Kesehatan (Health Law): emerald-600 (green) theme
    * Fidusia (Insurance Law): orange-600 (orange) theme
  - Customize welcome messages and example questions for each agent's domain
  - Maintain consistent UI structure across all ChatPage components
  - Use the same formatMessage function for consistent markdown rendering
  - Implement proper session management with initializeSession and clearChatHistory
  - Use consistent error handling and loading states

### Mobile Responsiveness & URL Handling Best Practices

- **Responsive Message Container Layout**:
  ```typescript
  // Optimal mobile-responsive message container structure
  <div className={cn("flex w-full", message.role === "user" ? "justify-end" : "justify-start")}>
    <div className={cn("flex gap-3 w-full max-w-full", 
      message.role === "user" ? "flex-row-reverse max-w-[85%] sm:max-w-[80%]" : "flex-row")}>
      <div className={cn("min-w-0 flex-1", 
        message.role === 'user' ? "order-first max-w-full" : "max-w-full")}>
  ```

- **Long URL and Text Breaking**:
  ```typescript
  // Comprehensive text breaking for URLs and long content
  className="prose prose-sm max-w-none
    [&_a]:text-rose-600 [&_a]:underline [&_a]:break-all [&_a]:hyphens-auto [&_a]:word-break-break-all
    [&_p]:mb-4 [&_p]:leading-relaxed [&_p]:break-words [&_p]:hyphens-auto
    text-gray-800 leading-relaxed break-words hyphens-auto word-wrap-break-word overflow-wrap-anywhere"
  ```

- **Mobile Container Optimization**:
  - Use `min-w-0 flex-1` instead of fixed `max-w-[80%]` for message containers
  - Add `overflow-x-auto -mx-2 sm:-mx-4` wrapper for horizontal scrollable content
  - Implement responsive padding: `px-3 sm:px-4 md:px-8` for consistent spacing
  - Use responsive max-width: `max-w-full sm:max-w-4xl xl:max-w-5xl`

- **Avatar and Layout Fixes**:
  - Add `flex-shrink-0` to avatars to prevent compression
  - Use smaller gap on mobile: `gap-3` instead of `gap-4`
  - Implement responsive margins: `max-w-[85%] sm:max-w-[80%]` for user messages

- **Table Responsiveness** (following established pattern):
  ```typescript
  [&_table]:min-w-[600px] [&_table]:overflow-hidden
  [&_td]:break-words [&_td]:hyphens-auto
  [&_th]:whitespace-nowrap [&_th]:max-w-[200px]
  [&_td:last-child]:max-w-[400px]
  ```

- **Input Area Mobile Optimization**:
  - Responsive padding: `p-3 sm:p-4 md:px-8`
  - Consistent container sizing with chat area
  - Proper spacing for file preview areas on mobile

- **Content Breaking Strategy**:
  - `word-wrap-break-word` for natural text flow (ChatGPT-like)
  - `overflow-wrap-break-word` as fallback for extreme cases
  - **AVOID**: `break-all`, `word-break-break-all`, `hyphens-auto` (too aggressive)
  - `whitespace-pre-wrap` for user messages with natural breaking
  - **Best Practice**: Use CSS that mimics ChatGPT's natural text flow without forced hyphenation

### ChatGPT-Style UI Implementation

- **Modern Clean Design Pattern**:
  ```typescript
  // User messages: Soft light bubble with rounded corners
  className="bg-gray-200 text-gray-800 rounded-3xl px-4 py-2.5 ml-auto"
  
  // Agent messages: No background, plain text with avatar
  className="bg-transparent"
  
  // Container: Clean white background without distracting patterns
  className="bg-white max-w-3xl mx-auto"
  ```

- **Avatar Design**:
  - Small circular avatars: `w-7 h-7 rounded-full`
  - User: `bg-gray-400` with white text (soft tone)
  - Agent: theme color (e.g., `bg-rose-500` for KUHP)
  - Positioned with `mt-1` for alignment with text
  - Use `flex-shrink-0` to prevent compression

- **Typography & Content**:
  - Clean prose styling with `prose-gray` for neutral appearance
  - Links: `text-blue-600 no-underline hover:underline` 
  - Headers: `font-semibold text-gray-900` instead of themed colors
  - Reduced spacing: `mb-3` for paragraphs, `space-y-1` for lists
  - Code blocks: subtle `bg-gray-100 border` with proper `font-mono`

- **Interactive Elements**:
  - Copy button: `opacity-0 group-hover:opacity-100` for subtle appearance
  - Small icons: `h-3 w-3` for copy buttons
  - Positioned at `justify-start` instead of `justify-end`
  - Minimal padding: `h-6 px-2` for compact appearance

  - **Input Area**:
  - ChatGPT-style placeholder: "Message [Agent Name]..."
  - Rounded input: `rounded-2xl border-gray-300`
  - Subtle focus: `focus:border-gray-400 focus:ring-0`
  - Small action buttons: `w-8 h-8` with `rounded-lg`
  - Send button: Use native `<button>` instead of `<Button>` component to avoid CSS conflicts
  - Send button styling: `bg-blue-600 hover:bg-blue-700` with white icons for visibility
  - File upload button: `text-gray-500 hover:bg-gray-100` for subtle appearance
  - **Important**: For small icon buttons, native elements often work better than component library elements

- **Layout Improvements**:
  - Remove decorative backgrounds (DotBackground)
  - Consistent max-width: `max-w-3xl` for ChatGPT-like reading width
  - Clean spacing: `space-y-6` for message separation
  - Remove timestamps unless on hover
  - Minimize visual clutter while maintaining functionality

### Professional File Upload Implementation Patterns

### Mobile File Upload Compatibility

Untuk memastikan file upload bekerja optimal di mobile dan desktop, ikuti patterns berikut:

#### 1. Comprehensive File Type Support:
```typescript
// Lengkap sesuai Google Gemini API documentation
const ACCEPTED_FILE_TYPES = ".pdf,.txt,.html,.css,.md,.csv,.xml,.rtf,.js,.py,.doc,.docx,.xls,.xlsx,.png,.jpg,.jpeg,.webp";

// MIME type validation dengan fallback extension checking untuk mobile compatibility
const SUPPORTED_MIME_TYPES = [
  'application/pdf', 'text/plain', 'text/html', 'text/css', 'text/markdown',
  'text/csv', 'text/xml', 'application/rtf', 'application/javascript',
  'text/javascript', 'application/x-javascript', 'text/x-python',
  'application/x-python', 'application/msword', 
  'application/vnd.openxmlformats-officedocument.wordprocessingml.document',
  'application/vnd.ms-excel',
  'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet',
  'image/png', 'image/jpeg', 'image/jpg', 'image/webp'
];
```

#### 2. File Validation dengan Mobile Fallback:
```typescript
const validateFile = (file: File): { isValid: boolean; error?: string } => {
  // Size validation (20MB for Gemini API)
  if (file.size > MAX_FILE_SIZE) {
    return { isValid: false, error: `File terlalu besar...` };
  }

  // MIME type validation dengan extension fallback untuk mobile
  if (!SUPPORTED_MIME_TYPES.includes(file.type)) {
    const extension = file.name.toLowerCase().split('.').pop();
    const extensionMimeMap = { /* mapping object */ };
    if (!extension || !extensionMimeMap[extension]) {
      return { isValid: false, error: `Format tidak didukung...` };
    }
  }
  return { isValid: true };
};
```

#### 3. Enhanced File Change Handler:
```typescript
const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
  const files = Array.from(e.target.files || []);
  const errors: string[] = [];
  const validFiles: File[] = [];

  // Validate setiap file
  files.forEach((file, index) => {
    console.log(`üìÑ File ${index + 1}: ${file.name} (${formatFileSize(file.size)}, ${file.type})`);
    const validation = validateFile(file);
    if (validation.isValid) {
      validFiles.push(file);
    } else {
      errors.push(validation.error!);
    }
  });

  // Update error state dan process valid files only
  setFileValidationErrors(errors);
  if (validFiles.length > 0) {
    // Create new DataTransfer dengan valid files
    const dataTransfer = new DataTransfer();
    validFiles.forEach(file => dataTransfer.items.add(file));
    // Process dengan originalHandleFileChange
  }
  
  // Clear input untuk re-selection dan auto-clear errors
  e.target.value = '';
  if (errors.length > 0) {
    setTimeout(() => setFileValidationErrors([]), 5000);
  }
};
```

#### 4. Professional File Preview UI:
```typescript
{selectedFiles.length > 0 && (
  <div className="mb-3 space-y-2">
    <div className="text-xs text-gray-600 font-medium">
      File terpilih ({selectedFiles.length}):
    </div>
    <div className="flex flex-wrap gap-2">
      {selectedFiles.map((file, index) => (
        <div className="bg-rose-50 border border-rose-200 rounded-lg px-3 py-2 flex items-center gap-2">
          <File className="w-4 h-4 flex-shrink-0" />
          <div className="flex flex-col min-w-0 flex-1">
            <span className="truncate font-medium">{file.name}</span>
            <span className="text-xs text-rose-500">
              {formatFileSize(file.size)} ‚Ä¢ {file.type || 'Unknown type'}
            </span>
          </div>
          <button onClick={() => handleRemoveFile(index)}>
            <XIcon className="w-4 h-4" />
          </button>
        </div>
      ))}
    </div>
  </div>
)}
```

#### 5. File Validation Error UI:
```typescript
{fileValidationErrors.length > 0 && (
  <div className="bg-red-50 border-l-4 border-red-400 p-4 rounded-md mb-4">
    <div className="flex">
      <AlertCircle className="h-5 w-5 text-red-400" />
      <div className="ml-3">
        <h3 className="text-sm font-medium text-red-800">Error Validasi File</h3>
        <ul className="list-disc list-inside space-y-1">
          {fileValidationErrors.map((error, index) => (
            <li key={index}>{error}</li>
          ))}
        </ul>
        <div className="mt-3 text-xs text-red-600">
          <p><strong>Format yang didukung:</strong> PDF, TXT, HTML, CSS, MD, CSV, XML, RTF, JS, PY, DOC, DOCX, XLS, XLSX, PNG, JPG, JPEG, WEBP</p>
          <p><strong>Ukuran maksimal:</strong> 20MB per file</p>
        </div>
      </div>
    </div>
  </div>
)}
```

### Best Practices untuk Mobile Compatibility:
- **Accept Attribute**: Gunakan file extension format, bukan MIME types di accept attribute
- **MIME Type Fallback**: Validate dengan MIME type tapi fallback ke extension untuk mobile compatibility
- **File Size Display**: Tampilkan ukuran file dan type untuk transparency
- **Auto-clear Errors**: Error validation auto-clear setelah 5 detik untuk UX yang bersih
- **Detailed Logging**: Log file details untuk debugging upload issues
- **Input Reset**: Reset input value setelah file change untuk allow re-selection
- **Professional UI**: File preview dengan detailed information (name, size, type)
- **Responsive Design**: File preview yang responsive dengan proper truncation

## File Upload Implementation Patterns

1. State Management untuk File Upload:
   ```typescript
   // State untuk tracking file
   const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
   // State untuk progress
   const [progress, setProgress] = useState<{status: string, percent: number}>({
     status: 'preparing',
     percent: 0
   });
   const [showProgress, setShowProgress] = useState(false);
   ```

2. Implementasi File Input dan Handler:
   ```typescript
   // Ref untuk input file yang disembunyikan
   const fileInputRef = useRef<HTMLInputElement>(null);
   
   // Handler untuk perubahan file
   const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
     if (e.target.files) {
       const filesArray = Array.from(e.target.files);
       setSelectedFiles(prev => [...prev, ...filesArray]);
     }
   };
   
   // Handler untuk menghapus file
   const handleRemoveFile = (indexToRemove: number) => {
     setSelectedFiles(prev => prev.filter((_, index) => index !== indexToRemove));
   };
   
   // Fungsi untuk membuka dialog file
   const handleOpenFileDialog = () => {
     if (fileInputRef.current) {
       fileInputRef.current.click();
     }
   };
   ```

3. Komponen Progress Bar:
   ```typescript
   // Progress bar component
   const ProgressBar = ({ percent = 0, status = 'uploading' }) => {
     const getStatusText = () => {
       switch (status) {
         case 'preparing': return 'Mempersiapkan...';
         case 'uploading': return 'Mengunggah file...';
         case 'processing': return 'Memproses dokumen...';
         case 'completed': return 'Selesai!';
         default: return 'Memproses...';
       }
     };
     
     const getColor = () => {
       switch (status) {
         case 'completed': return 'bg-green-500';
         case 'processing': return 'bg-blue-500';
         case 'uploading': return 'bg-amber-500';
         default: return 'bg-blue-500';
       }
     };
     
     return (
       <div className="w-full mb-3">
         <div className="flex justify-between items-center mb-1">
           <span className="text-sm font-medium text-gray-700">{getStatusText()}</span>
           <span className="text-sm font-medium text-gray-700">{percent}%</span>
         </div>
         <div className="w-full bg-gray-200 rounded-full h-2.5">
           <div 
             className={`h-2.5 rounded-full ${getColor()} transition-all duration-500 ease-in-out`} 
             style={{ width: `${percent}%` }}
           ></div>
         </div>
       </div>
     );
   };
   ```

4. UI Elements untuk File Upload:
   ```typescript
   {/* File Upload Button */}
   <button
     type="button"
     onClick={handleOpenFileDialog}
     disabled={isProcessing}
     className="absolute left-2 bottom-3 p-2 rounded-lg text-gray-500 hover:text-blue-500 hover:bg-blue-50 transition-colors z-20"
     aria-label="Upload file"
   >
     <Paperclip className="w-5 h-5" />
   </button>
   
   {/* Hidden file input */}
   <input 
     type="file" 
     ref={fileInputRef}
     onChange={handleFileChange}
     className="hidden"
     multiple
     accept=".pdf,.doc,.docx,.txt,.csv,.xls,.xlsx,.jpg,.jpeg,.png"
   />
   
   {/* File Preview Area */}
   {selectedFiles.length > 0 && (
     <div className="mb-3 flex flex-wrap gap-2">
       {selectedFiles.map((file, index) => (
         <div 
           key={index}
           className="bg-blue-50 border border-blue-200 rounded-lg px-3 py-1 flex items-center gap-2 text-sm text-blue-700"
         >
           <File className="w-4 h-4" />
           <span className="truncate max-w-[150px]">{file.name}</span>
           <button 
             onClick={() => handleRemoveFile(index)}
             className="text-blue-500 hover:text-blue-700"
             aria-label="Hapus file"
           >
             <XIcon className="w-4 h-4" />
           </button>
         </div>
       ))}
     </div>
   )}
   
   {/* Progress Bar UI */}
   {showProgress && (
     <div className="bg-white border border-gray-200 rounded-xl p-4 mb-4 shadow-sm">
       <ProgressBar 
         percent={progress.percent} 
         status={progress.status}
       />
       <p className="text-xs text-gray-500 italic">
         {progress.status === 'uploading' 
           ? 'Mengunggah file besar memerlukan waktu, mohon jangan refresh halaman.' 
           : progress.status === 'processing'
           ? 'AI sedang menganalisis dokumen, proses ini mungkin memerlukan beberapa menit untuk file besar.'
           : 'Sedang memproses...'}
       </p>
     </div>
   )}
   ```

5. Integrasi dengan Progress API:
   ```typescript
   // Setup progress listener
   useEffect(() => {
     const unsubscribe = onProgress((progressInfo) => {
       setProgress({
         status: progressInfo.status,
         percent: progressInfo.percent || 0
       });
       
       if (progressInfo.status === 'completed') {
         // Hide progress after completion + delay
         setTimeout(() => {
           setShowProgress(false);
         }, 1000);
       } else {
         setShowProgress(true);
       }
     });
     
     return () => {
       unsubscribe();
     };
   }, []);
   ```

6. File Size Checking:
   ```typescript
   // Check if any file is large (> 5MB)
   const hasLargeFile = selectedFiles.some(file => file.size > 5 * 1024 * 1024);
   if (hasLargeFile) {
     setShowProgress(true);
   }
   
   // Log file sizes sebelum upload
   if (selectedFiles.length > 0) {
     console.log('Uploading files:');
     selectedFiles.forEach((file, index) => {
       console.log(`File ${index + 1}: ${file.name} - ${(file.size / 1024 / 1024).toFixed(2)}MB`);
     });
   }
   ```

7. Error Handling untuk Upload File:
   ```typescript
   // Fungsi untuk menampilkan error yang lebih spesifik
   const getErrorMessage = (error: any): string => {
     if (!navigator.onLine) {
       return 'Perangkat Anda sedang offline. Silakan periksa koneksi internet dan coba lagi.';
     }
     
     if (error.message) {
       // Jika error spesifik tentang ukuran file
       if (error.message.includes('File terlalu besar')) {
         return 'File terlalu besar. Harap gunakan file dengan ukuran lebih kecil (maksimal 50MB).';
       }
       
       // Jika error timeout
       if (error.message.includes('timeout') || error.message.includes('timed out')) {
         return 'Permintaan timeout. File mungkin terlalu besar atau koneksi terlalu lambat.';
       }
       
       // Jika error spesifik tentang rate limit
       if (error.message.includes('Terlalu banyak permintaan')) {
         return 'Terlalu banyak permintaan dalam waktu singkat. Silakan tunggu beberapa saat dan coba lagi.';
       }
       
       // Jika ada pesan error spesifik lainnya, tampilkan
       return error.message;
     }
     
     // Default error message
     return 'Permintaan Terlalu banyak, coba lagi dalam 2 menit. (dengan bertumbuhnya pengguna, saat ini kami membatasi permintaan untuk menjaga kualitas layanan)';
   };
   ```

8. Best Practices untuk File Upload:
   - Gunakan accept attribute untuk membatasi jenis file yang dapat diunggah
   - Tampilkan progress bar khususnya untuk file besar
   - Berikan feedback visual untuk status upload (warna berbeda untuk status berbeda)
   - Tampilkan pesan informatif selama proses upload
   - Implementasikan mekanisme untuk menghapus file sebelum upload
   - Truncate nama file yang terlalu panjang dengan class `truncate max-w-[150px]`
   - Log ukuran file untuk debugging
   - Nonaktifkan tombol upload selama proses upload
   - Berikan pesan error yang spesifik untuk masalah umum (file terlalu besar, timeout, offline)
   - Reset selectedFiles setelah upload berhasil

9. Integrasi dengan Form Submission:
   ```typescript
   // Tetap memungkinkan submit jika ada file yang dipilih, bahkan jika inputMessage kosong
   if ((selectedFiles.length === 0 && !inputMessage.trim()) || isProcessing) return;
   
   // Jika pesan kosong tapi ada file, tampilkan pesan default
   content: inputMessage.trim() || (selectedFiles.length > 0 ? "Tolong analisis file yang saya kirimkan." : ""),
   
   // Kirim pesan dengan file jika ada
   const response = await sendChatMessage(
     userMessage.content, 
     selectedFiles.length > 0 ? selectedFiles : undefined
   );
   
   // Reset selected files setelah berhasil mengirim
   setSelectedFiles([]);
   setShowProgress(false);
   ```

## AGNO Streaming Status Animations Implementation Pattern

### Overview
Implementasi real-time streaming status animations untuk AGNO API yang menunjukkan proses AI secara detail (thinking, tool calls, memory updates) dengan positioning yang tepat dalam message bubbles.

### 1. StreamingStatus Component Architecture

#### Component Structure (src/components/ui/StreamingStatus.tsx):
```typescript
interface StreamingStatusProps {
  streamingStatus: StreamingStatus;
  compact?: boolean; // untuk display dalam message bubble
}

// Phases yang didukung:
// - Thinking: Brain icon + bouncing dots
// - Tool Call: Wrench icon + spinning loader  
// - Memory Update: Database icon + pulsing bars
// - Completion: CheckCircle icon
```

#### Animation Patterns:
- **Thinking Phase**: 
  * Icon: Brain dengan animate-pulse
  * Animation: 3 bouncing dots dengan staggered delays (0ms, 150ms, 300ms)
  * Text: "Menganalisis pertanyaan..."
  
- **Tool Call Phase**:
  * Icon: Wrench dengan animate-spin
  * Animation: Spinning wrench + rotating Loader2
  * Text: "Menggunakan {toolName}..." atau "Mengakses knowledge base..."
  
- **Memory Update Phase**:
  * Icon: Database dengan animate-pulse  
  * Animation: 3 vertical pulsing bars dengan staggered delays
  * Text: "Menyimpan informasi ke memori..."
  
- **Completion Phase**:
  * Icon: CheckCircle (static green)
  * Text: "Respons selesai"

#### Progress Indicators:
- **Visual**: Colored dots showing current phase
- **Colors**: Purple (thinking), Blue (knowledge), Green (memory)
- **Labels**: "Thinking", "Knowledge Access", "Memory Update"

### 2. State Management Pattern

#### StreamingStatus Interface (src/types/playground.ts):
```typescript
interface StreamingStatus {
  isThinking: boolean;
  isCallingTool: boolean;
  toolName?: string;
  isUpdatingMemory: boolean;
  hasCompleted: boolean;
}
```

#### Store Integration (src/stores/PlaygroundStore.ts):
```typescript
// State management functions
setStreamingStatus: (status: Partial<StreamingStatus>) => void;
resetStreamingStatus: () => void;

// Usage pattern
const { streamingStatus, setStreamingStatus, resetStreamingStatus } = usePlaygroundStore();
```

### 3. Event Handler Pattern

#### useAIChatStreamHandler Integration:
```typescript
// RunStarted: Initialize thinking phase
setStreamingStatus({ isThinking: true });

// ToolCallStarted: Begin tool call phase  
setStreamingStatus({ 
  isThinking: false, 
  isCallingTool: true, 
  toolName: event.data?.name || 'knowledge base' 
});

// ToolCallCompleted: End tool call phase
setStreamingStatus({ isCallingTool: false, toolName: undefined });

// UpdatingMemory: Begin memory update phase
setStreamingStatus({ isUpdatingMemory: true });

// RunCompleted: Complete all phases
setStreamingStatus({ 
  hasCompleted: true,
  isThinking: false,
  isCallingTool: false, 
  isUpdatingMemory: false 
});

// Reset after delay for new conversations
setTimeout(() => resetStreamingStatus(), 1000);
```

### 4. Per-Message Animation Positioning

#### Detection Logic untuk Streaming Message:
```typescript
const isStreamingMessage = message.role === 'agent' && 
                         isLastMessage && 
                         isLoading &&
                         (hasMinimalContent || 
                          streamingStatus.isThinking || 
                          streamingStatus.isCallingTool || 
                          streamingStatus.isUpdatingMemory);

// hasMinimalContent = content length < 50 characters
const hasMinimalContent = message.content && message.content.length < 50;
```

#### Positioning Strategy:
- **Location**: Inside agent message bubble yang sedang streaming
- **Placement**: Di atas content dengan `mb-3` spacing
- **Styling**: Compact design (`bg-purple-50`, `w-4 h-4` icons, `text-xs`)
- **Real-time**: Animasi selalu muncul di message yang sedang aktif

### 5. UI Integration Pattern

#### Chat Component Integration:
```typescript
// Dalam message rendering loop
{isStreamingMessage && (
  <div className="mb-3">
    <StreamingStatus 
      streamingStatus={streamingStatus} 
      compact={true}
    />
  </div>
)}

// Conditional copy button (hanya muncul jika ada content)
{message.content && (
  <button 
    onClick={() => copyToClipboard(message.content)}
    className="opacity-0 group-hover:opacity-100 transition-opacity"
  >
    <Copy className="w-4 h-4" />
  </button>
)}

// Empty message placeholder
{!message.content && isStreamingMessage && (
  <p className="text-gray-500 italic text-sm">Sedang memproses...</p>
)}
```

### 6. Timing Detection Best Practices

#### Critical Implementation Notes:
- **Avoid skeleton conflicts**: Jangan gunakan skeleton loading bersamaan dengan streaming animations
- **Message state detection**: Gunakan multiple criteria untuk detecting streaming message
- **Empty content handling**: Provide placeholder text untuk message kosong saat streaming
- **Conditional rendering**: Copy/action buttons hanya muncul jika ada content
- **Animation lifecycle**: Reset status setelah completion dengan appropriate delay

#### Common Pitfalls:
- **Late animation appearance**: Pastikan detection logic menggunakan streaming status, bukan hanya isLoading
- **Global positioning**: Hindari global animation positioning yang memerlukan scroll
- **Skeleton interference**: Hindari skeleton yang menutupi atau conflict dengan streaming animations
- **Timing issues**: Gunakan proper criteria untuk mendeteksi kapan animasi harus muncul

### 7. Implementation Checklist

#### Required Files:
- [ ] `src/components/ui/StreamingStatus.tsx` - Main animation component
- [ ] `src/types/playground.ts` - StreamingStatus interface
- [ ] `src/stores/PlaygroundStore.ts` - State management functions
- [ ] Enhanced `useAIChatStreamHandler.ts` - Event handlers
- [ ] Updated chat component - Message-level integration

#### Required Dependencies:
- [ ] Lucide icons: Brain, Wrench, Database, CheckCircle, Loader2
- [ ] Tailwind CSS animations: animate-pulse, animate-spin, animate-bounce
- [ ] Zustand store for state management

#### Validation Steps:
- [ ] Test thinking phase animation (brain + bouncing dots)
- [ ] Test tool call phase animation (wrench + spinner)
- [ ] Test memory update phase animation (database + pulsing bars)
- [ ] Test completion phase (checkmark)
- [ ] Verify per-message positioning (no global scrolling required)
- [ ] Test empty message handling (placeholder text)
- [ ] Test conditional copy button (only with content)

### 8. Benefits & UX Impact

#### User Experience Improvements:
- **Real-time Feedback**: User melihat proses AI secara detail dan real-time
- **Better Understanding**: Jelas menunjukkan fase mana yang sedang berjalan
- **Professional Appearance**: Animasi yang smooth dan sesuai dengan AI workflow
- **No Scroll Required**: Animasi muncul di tempat yang sedang user lihat
- **Event-Driven**: UI update berdasarkan actual streaming events dari backend

#### Technical Benefits:
- **Modular Design**: Component dapat digunakan ulang untuk agent lain
- **Type Safety**: Full TypeScript support dengan proper interfaces
- **Performance**: Minimal overhead dengan efficient state management
- **Maintainable**: Clear separation of concerns dan well-documented patterns

### 9. Extension Guidelines

#### Untuk Agent Baru:
- Gunakan usePlaygroundStore pattern yang sama
- Implement useAIChatStreamHandler dengan proper event mapping
- Use StreamingStatus component dengan compact mode
- Follow detection logic pattern untuk per-message positioning

#### Untuk Animasi Baru:
- Tambahkan phase baru di StreamingStatus interface
- Implement animation pattern dengan staggered delays
- Gunakan appropriate Lucide icons
- Maintain compact design untuk in-message display

#### Performance Considerations:
- Reset streaming status setelah completion
- Avoid memory leaks dengan proper cleanup
- Use efficient re-render patterns
- Minimize animation complexity untuk mobile performance

## Citation Implementation Pattern from Knowledge Base Streaming

### Overview
Implementasi comprehensive untuk menampilkan citations dari knowledge base responses dalam streaming chat applications. Pattern ini mencakup parsing extra_data.references, display component dengan professional styling, dan real-time citation integration.

### 1. Stream Response Citation Parsing

#### RunEvent.RunResponse Handler Enhancement:
```typescript
case RunEvent.RunResponse:
  // Accumulate content incrementally
  if (event.content && typeof event.content === 'string') {
    setMessages(prev => {
      const newMessages = [...prev];
      const lastAgentMessage = newMessages[newMessages.length - 1];
      if (lastAgentMessage && lastAgentMessage.role === 'agent') {
        // Append new content to existing content
        lastAgentMessage.content = (lastAgentMessage.content || '') + event.content;
        
        // Parse and store citations from extra_data.references
        if (event.extra_data?.references && event.extra_data.references.length > 0) {
          console.log('üîó Citations found in response:', {
            referencesCount: event.extra_data.references.length,
            hasQuery: !!event.extra_data.references[0]?.query,
            sourceDocs: event.extra_data.references.map(ref => 
              ref.references?.map(r => r.name).filter(Boolean) || []
            ).flat()
          });
          
          // Store references in message extra_data
          if (!lastAgentMessage.extra_data) {
            lastAgentMessage.extra_data = {};
          }
          lastAgentMessage.extra_data.references = event.extra_data.references;
        }
      }
      return newMessages;
    });
  }
  break;
```

#### RunEvent.RunCompleted Handler Enhancement:
```typescript
case RunEvent.RunCompleted:
  // Update final content and ensure citations are preserved
  if (event.content && typeof event.content === 'string' && event.content.trim()) {
    setMessages(prev => {
      const newMessages = [...prev];
      const lastAgentMessage = newMessages[newMessages.length - 1];
      if (lastAgentMessage && lastAgentMessage.role === 'agent') {
        // Set final content or update if final content is longer/better
        if (!lastAgentMessage.content || lastAgentMessage.content.length < event.content.length) {
          lastAgentMessage.content = event.content as string;
        }
        
        // Ensure final citations are stored
        if (event.extra_data?.references && event.extra_data.references.length > 0) {
          if (!lastAgentMessage.extra_data) {
            lastAgentMessage.extra_data = {};
          }
          lastAgentMessage.extra_data.references = event.extra_data.references;
          
          console.log('üèÅ Final citations stored:', {
            referencesCount: event.extra_data.references.length,
            messageHasContent: !!lastAgentMessage.content
          });
        }
      }
      return newMessages;
    });
  }
  break;
```

### 2. Citation Display Component Architecture

#### Component Structure (src/components/ui/CitationDisplay.tsx):
```typescript
interface CitationReference {
  content: string;
  meta_data?: {
    chunk?: number;
    chunk_size?: number;
    [key: string]: any;
  };
  name: string;
}

interface CitationGroup {
  query?: string;
  references?: CitationReference[];
  time?: number;
}

interface CitationDisplayProps {
  references?: CitationGroup[];
  compact?: boolean;
  className?: string;
}
```

#### Professional Gray-Based Color Scheme:
- **Container**: `border-gray-200/60` + `bg-gray-50/80` dengan `backdrop-blur-sm`
- **Headers**: `bg-gray-100/50` untuk header backgrounds
- **Text Colors**: `text-gray-700` (primary) / `text-gray-600` (secondary)
- **Accent Colors**: Subtle blue (`text-blue-600`) untuk interactive elements
- **Icons**: `text-gray-500` untuk neutral, `text-blue-500` untuk active
- **Borders**: `border-gray-200` untuk subtle separation
- **Hover States**: `hover:bg-gray-50` untuk gentle interactions

### 3. Citation UI Integration Pattern

#### Chat Message Integration:
```typescript
{/* Main message content */}
{message.content ? (
  <div 
    className={getProseClasses()}
    dangerouslySetInnerHTML={{ __html: formatMessage(message.content) }}
  />
) : (
  <div className="text-gray-400 text-sm italic">
    Sedang memproses...
  </div>
)}

{/* Citations Display */}
{message.extra_data?.references && message.extra_data.references.length > 0 && (
  <div className="mt-4">
    <CitationDisplay 
      references={message.extra_data.references as any}
      compact={false}
    />
  </div>
)}

{/* Action buttons (conditional on content) */}
{message.content && (
  <div className="flex justify-end mt-2">
    <Button variant="ghost" size="sm" onClick={() => copyToClipboard(message.content)}>
      {copiedMessage === message.id ? (
        <Check className="w-4 h-4 text-green-600" />
      ) : (
        <Copy className="w-4 h-4" />
      )}
    </Button>
  </div>
)}
```

### 4. Citation Component Features

#### Expandable Content Structure:
- **Header Summary**: Shows total references and document count
- **Query Display**: Shows search queries used with time stamps
- **Reference Cards**: Individual source documents with metadata
- **Content Preview**: Truncated content with expand option for long texts
- **Document Metadata**: Chunk information and source file names

#### Interactive Elements:
- **Expandable Groups**: Click to expand/collapse reference groups
- **Content Truncation**: Smart truncation at 1000 characters with indicator
- **Professional Hover Effects**: Subtle gray hover states
- **Backdrop Blur**: Modern glass effect with `backdrop-blur-sm`
- **Responsive Design**: Proper spacing and sizing for all screen sizes

### 5. Styling Guidelines

#### Professional Color Implementation:
```typescript
// Container styling
className="border border-gray-200/60 rounded-lg bg-gray-50/80 backdrop-blur-sm"

// Header styling  
className="px-4 py-3 border-b border-gray-200/60 bg-gray-100/50"

// Interactive buttons
className="flex items-center gap-2 w-full text-left hover:bg-gray-50 rounded-md p-2 transition-colors"

// Text hierarchy
className="font-medium text-gray-700"  // Primary headers
className="text-gray-600"              // Secondary text
className="text-xs text-gray-500"      // Metadata text

// Accent colors (minimal usage)
className="text-blue-600"              // Links and active states
className="bg-blue-50 text-blue-700"   // Subtle highlights
```

#### Visual Enhancement Principles:
- **Transparency Layering**: Use `/50`, `/60`, `/80` opacity modifiers
- **Subtle Depth**: `shadow-sm` for gentle elevation without overwhelming
- **Glass Effects**: `backdrop-blur-sm` for modern sophisticated appearance
- **Consistent Spacing**: `gap-2`, `px-4 py-3`, `mt-4` for rhythm
- **Professional Contrast**: Gray-based palette maintains readability

### 6. Required Dependencies

#### Component Dependencies:
```typescript
import React, { useState } from 'react';
import { ChevronDown, ChevronRight, FileText, Search, Clock, Database } from 'lucide-react';
import { cn } from '@/utils/utils';
```

#### Integration Requirements:
- **Message Interface**: Extend `PlaygroundChatMessage` to include `extra_data.references`
- **Stream Handler**: Enhanced event handlers for `RunResponse` and `RunCompleted`
- **Import Path**: Add `CitationDisplay` import to chat components

### 7. Implementation Best Practices

#### Citation Data Handling:
- **Type Safety**: Proper TypeScript interfaces for citation structure
- **Conditional Rendering**: Only show citations when references exist
- **Content Validation**: Validate citation data before rendering
- **Error Boundaries**: Graceful handling of malformed citation data

#### Performance Considerations:
- **Lazy Rendering**: Only render expanded content when needed
- **Memoization**: Use React.memo for citation components if needed
- **Content Limits**: Truncate very long citation content for performance
- **State Management**: Efficient expand/collapse state handling

### 8. Professional UI Standards

#### Design Principles for Law Enforcement Applications:
- **Monochromatic Elegance**: Gray-based palette for professional appearance
- **Subtle Interactions**: Gentle hover effects without overwhelming users
- **Information Hierarchy**: Clear visual distinction between headers and content
- **Accessibility**: Proper contrast ratios and semantic markup
- **Consistency**: Unified styling across all citation components

#### Mobile Responsiveness:
- **Touch Targets**: Adequate button sizes for mobile interaction
- **Content Scaling**: Responsive text sizes and spacing
- **Scroll Areas**: Proper scroll behavior for long citation lists
- **Compact Mode**: Optional compact display for space-constrained layouts

### 9. Extension Guidelines

#### For New Chat Components:
- Import `CitationDisplay` component
- Add citation integration in message rendering
- Enhance stream event handlers for citation parsing
- Follow established color scheme and styling patterns

#### For Custom Citation Types:
- Extend citation interfaces for new data structures
- Implement custom rendering for specialized citation formats
- Maintain consistency with professional styling guidelines
- Add appropriate metadata display for domain-specific sources

#### Testing & Validation:
- Test citation display with various reference counts
- Validate expandable content behavior
- Ensure proper mobile responsiveness
- Test citation parsing with different stream response formats

## History Management & Storage Optimization Implementation Pattern

### Overview
Implementasi comprehensive untuk mengelola history chat messages, mencegah pembebanan server, dan mengoptimalkan penggunaan localStorage dengan auto-cleanup dan monitoring.

### 1. Configuration Constants

#### Storage Limits (src/stores/PlaygroundStore.ts):
```typescript
// History management constants
const MAX_MESSAGES_PER_SESSION = 100; // Maksimal 100 pesan per session
const MAX_STORED_SESSIONS = 10; // Maksimal 10 session tersimpan
const MESSAGE_CLEANUP_THRESHOLD = 80; // Mulai cleanup saat mencapai 80 pesan
const SESSION_EXPIRY_DAYS = 7; // Session kadaluarsa setelah 7 hari
const STORAGE_SIZE_LIMIT = 5 * 1024 * 1024; // 5MB limit untuk localStorage
```

#### Benefits:
- **Configurable Limits**: Easy to adjust based on requirements
- **Tiered Cleanup**: Different thresholds for different actions
- **Memory Efficiency**: Prevents unlimited memory growth
- **User Experience**: Balances performance with functionality

### 2. Auto-Cleanup Strategies

#### Message Limiting:
```typescript
addMessage: (message) => {
  set((state) => {
    const newMessages = [...state.messages, message];
    
    // Auto-limit messages per session
    if (newMessages.length > MAX_MESSAGES_PER_SESSION) {
      const messagesToRemove = newMessages.length - MAX_MESSAGES_PER_SESSION;
      return {
        messages: newMessages.slice(messagesToRemove)
      };
    }
    
    return { messages: newMessages };
  });
  
  // Save to localStorage with optimization
  optimizedSaveToStorage();
}
```

#### Smart Cleanup Function:
```typescript
const cleanupOldMessages = () => {
  const { messages, setMessages } = usePlaygroundStore.getState();
  
  if (messages.length > MESSAGE_CLEANUP_THRESHOLD) {
    // Keep only the most recent messages, maintaining conversation context
    const messagesToKeep = Math.floor(MESSAGE_CLEANUP_THRESHOLD * 0.7); // Keep 70% of threshold
    const recentMessages = messages.slice(-messagesToKeep);
    
    console.log(`üßπ Auto-cleanup: Removed ${messages.length - messagesToKeep} old messages`);
    setMessages(recentMessages);
  }
};
```

### 3. Session Management

#### Session Expiry:
```typescript
// Enhanced SessionEntry interface
interface SessionEntry {
  session_id: string;
  title: string;
  created_at: number;
  lastActivity?: number; // Timestamp of last activity for cleanup purposes
}
```

#### Expired Session Cleanup:
```typescript
const cleanupExpiredSessions = () => {
  // Check session creation time
  const sessionCreated = localStorage.getItem('wassidik_session_created');
  if (sessionCreated) {
    const daysSinceCreation = (Date.now() - parseInt(sessionCreated)) / (1000 * 60 * 60 * 24);
    
    if (daysSinceCreation > SESSION_EXPIRY_DAYS) {
      console.log(`üóëÔ∏è Session expired after ${daysSinceCreation.toFixed(1)} days`);
      clearSessionStorage();
      return;
    }
  }
  
  // Cleanup stored sessions by activity
  const validSessions = sessions.filter(session => {
    const daysSinceActivity = (Date.now() - session.lastActivity) / (1000 * 60 * 60 * 24);
    return daysSinceActivity <= SESSION_EXPIRY_DAYS;
  });
};
```

### 4. Storage Monitoring

#### Storage Usage Tracking:
```typescript
const getStorageUsage = (): number => {
  let total = 0;
  for (let key in localStorage) {
    if (localStorage.hasOwnProperty(key)) {
      total += localStorage[key].length + key.length;
    }
  }
  return total;
};

const getStorageStats = () => {
  const usage = getStorageUsage();
  const limit = STORAGE_SIZE_LIMIT;
  const percentage = (usage / limit) * 100;
  
  return {
    usage: formatBytes(usage),
    limit: formatBytes(limit),
    percentage: Math.round(percentage),
    sessionCount: Object.keys(localStorage).filter(key => key.startsWith('wassidik_session_')).length,
    isNearLimit: percentage > 80
  };
};
```

#### Optimized Storage Save:
```typescript
const optimizedSaveToStorage = () => {
  // Check current storage usage
  const currentUsage = getStorageUsage();
  if (currentUsage > STORAGE_SIZE_LIMIT) {
    console.warn(`‚ö†Ô∏è Storage usage exceeds limit, performing cleanup`);
    cleanupExpiredSessions();
    cleanupOldMessages();
  }
  
  // Save current session messages (only recent ones for performance)
  const recentMessages = messages.slice(-50); // Save only last 50 messages
  const sessionData = {
    sessionId,
    messages: recentMessages,
    lastActivity: Date.now(),
    messageCount: messages.length
  };
  
  localStorage.setItem(`wassidik_session_${sessionId}`, JSON.stringify(sessionData));
};
```

### 5. UI Integration

#### Storage Stats Component:
```typescript
const StorageStatsDisplay = () => (
  <div className="bg-blue-50 border-l-4 border-blue-500 p-4 m-4 shadow-sm rounded-md">
    <div className="flex">
      <Database className="h-5 w-5 text-blue-500" />
      <div className="ml-3 flex-1">
        <h3 className="text-sm font-medium text-blue-800">Statistik Penyimpanan</h3>
        <div className="mt-2 text-sm text-blue-700 space-y-2">
          <div className="flex justify-between">
            <span>Penggunaan Storage:</span>
            <span className="font-medium">{storageStats.usage} / {storageStats.limit}</span>
          </div>
          
          {/* Progress bar for storage usage */}
          <div className="w-full bg-gray-200 rounded-full h-2 mt-3">
            <div className={cn("h-2 rounded-full transition-all duration-300",
              storageStats.percentage > 80 ? "bg-red-500" : 
              storageStats.percentage > 60 ? "bg-yellow-500" : "bg-green-500"
            )}
            style={{ width: `${Math.min(storageStats.percentage, 100)}%` }}
            />
          </div>
          
          {storageStats.isNearLimit && (
            <div className="text-red-600 text-xs mt-2 font-medium">
              ‚ö†Ô∏è Storage hampir penuh! Pertimbangkan untuk membersihkan data lama.
            </div>
          )}
        </div>
        
        <button onClick={handleStorageCleanup} className="mt-3 inline-flex items-center gap-1">
          <Trash2 className="w-3 h-3" />
          Bersihkan Data Lama
        </button>
      </div>
    </div>
  </div>
);
```

#### Header Integration:
```typescript
// Add storage monitoring button to header
<Button 
  variant="ghost" 
  size="icon" 
  onClick={() => setShowStorageInfo(!showStorageInfo)}
  className="text-gray-500"
  title="Storage Info"
>
  <Database className="h-5 w-5" />
</Button>
```

### 6. Best Practices

#### Implementation Guidelines:
- **Progressive Cleanup**: Cleanup berbertahap berdasarkan usage percentage
- **User Awareness**: Tampilkan warning saat storage hampir penuh
- **Non-Intrusive**: Auto-cleanup berjalan di background tanpa mengganggu user
- **Recoverable**: Manual cleanup option untuk kontrol user
- **Monitoring**: Real-time storage statistics untuk transparency

#### Performance Optimizations:
- **Lazy Loading**: Load hanya recent messages untuk performance
- **Batch Operations**: Combine multiple cleanup operations
- **Efficient Storage**: Store hanya data essential, compress jika perlu
- **Background Processing**: Cleanup running in background thread

### 7. Error Handling

#### Storage Error Recovery:
```typescript
// Graceful error handling for storage operations
try {
  localStorage.setItem(key, value);
} catch (error) {
  console.warn('Storage full, attempting cleanup...');
  cleanupExpiredSessions();
  try {
    localStorage.setItem(key, value);
  } catch (retryError) {
    console.error('Storage still full after cleanup:', retryError);
    // Fallback: use in-memory storage
  }
}
```

#### User Communication:
- **Clear Messages**: Informative error messages untuk user
- **Action Suggestions**: Saran konkret untuk mengatasi masalah
- **Fallback Options**: Alternative solutions jika storage penuh

### 8. Extension Guidelines

#### For New Chat Components:
- Import `getStorageStats, forceCleanup` from PlaygroundStore
- Add storage monitoring UI dengan Database icon
- Implement `handleStorageCleanup` function
- Use optimized save patterns untuk message persistence

#### For Custom Cleanup Strategies:
- Extend cleanup constants untuk domain-specific requirements
- Add new cleanup triggers berdasarkan usage patterns
- Implement custom storage monitoring sesuai kebutuhan aplikasi
- Consider server-side cleanup coordination untuk multi-device sync

#### Monitoring & Analytics:
- Track storage usage patterns untuk optimization insights
- Monitor cleanup frequency untuk tuning thresholds
- Log user engagement dengan cleanup features
- Analyze performance impact dari history management

### 9. Server Coordination

#### API Considerations:
- **Pagination Support**: Implement server-side pagination untuk large histories
- **Sync Strategy**: Coordinate client cleanup dengan server storage
- **Conflict Resolution**: Handle conflicts antara local dan server state
- **Batch Updates**: Efficient batch operations untuk reduced server load

#### Implementation Pattern:
```typescript
// Server-coordinated cleanup
const syncWithServer = async () => {
  try {
    // Send local cleanup events to server
    await api.post('/sessions/cleanup', {
      sessionId,
      messageCount: messages.length,
      lastActivity: Date.now()
    });
  } catch (error) {
    console.warn('Failed to sync cleanup with server:', error);
  }
};
```

# Scratchpad

## Task: Streaming Events Fix untuk KUHAPChatPage.tsx - COMPLETED ‚úÖ

### Deskripsi:
User melaporkan masalah dengan KUHAPChatPage.tsx bahwa event-event streaming tidak muncul, tool calls tidak muncul, dan final response tidak ada.

### Root Cause:
- **Oversimplified Event Handling**: handleSendMessage hanya menggunakan basic event cases (RunStarted, RunResponse, RunCompleted, RunError)
- **Missing Tool Events**: Tidak ada handling untuk ToolCallStarted, ToolCallCompleted, AccessingKnowledge, UpdatingMemory
- **Incomplete Citation Handling**: Citations tidak di-parse dan store dengan benar di RunResponse dan RunCompleted
- **No Content Validation**: Tidak ada fallback untuk empty responses
- **Incomplete Status Management**: StreamingStatus tidak di-manage dengan comprehensive

### Solution Implemented:
```typescript
// ‚úÖ AFTER: Comprehensive event handling dengan semua event types
case RunEvent.ToolCallStarted:
  // Extract tool name dan set proper streaming status
case RunEvent.ToolCallCompleted:
  // Clear tool state
case RunEvent.AccessingKnowledge:
  // Set knowledge access state  
case RunEvent.UpdatingMemory:
case RunEvent.MemoryUpdateStarted:
  // Set memory update state
case RunEvent.MemoryUpdateCompleted:
  // Clear memory update state
case RunEvent.RunResponse:
  // Enhanced dengan citation parsing dan incremental content
case RunEvent.RunCompleted:
  // Enhanced dengan final content validation dan citation preservation
```

### Benefits:
- **‚úÖ Tool Call Animations**: Sekarang muncul dengan benar saat AI menggunakan tools
- **‚úÖ Memory Update Indicators**: Memory operations ter-display dengan proper animations
- **‚úÖ Citations Display**: References dari knowledge base ter-parse dan ditampilkan
- **‚úÖ Final Response Guarantee**: Selalu ada content final, dengan fallback message jika kosong
- **‚úÖ Enhanced Logging**: Comprehensive logging untuk debugging streaming issues
- **‚úÖ Smart Content Merging**: Final content tidak menimpa incremental content
- **‚úÖ Proper Status Reset**: Streaming status ter-reset dengan benar setelah completion

### Pattern Applied:
- **Complete Event Coverage**: Semua RunEvent types ter-handle dengan proper actions
- **Citation Preservation**: References tersimpan di both RunResponse dan RunCompleted events
- **Tool Name Extraction**: Extract tool names dari event.tool_calls atau event.tools
- **Content Validation**: Final check untuk memastikan ada content setelah completion
- **Status Lifecycle Management**: Proper initialization, updates, dan reset untuk streaming status
- **Enhanced Error Handling**: Comprehensive error logging dan fallback messaging

### Files Modified:
- `src/components/ui/KUHAPChatPage.tsx` - Enhanced event handling dalam handleSendMessage
- `.cursorrules` - Added comprehensive Streaming Events Fix Implementation Pattern

---

## Previous Completed Tasks:
- Streaming Events Fix untuk KUHAPChatPage.tsx
- HukumPerdataChatPage tampilan fix mengikuti KUHPChatPage.tsx pattern
- Citation mobile responsiveness fix untuk KUHPChatPage.tsx
- AdminPanel.tsx reject_user Function Fix
- Natural Text Flow Fix untuk ChatGPT-like Word Breaking
- Soft Background User Chat Implementation
- Send Button Visibility Fix untuk KUHPChatPage.tsx

## Instructions for Using Graphiti's MCP Tools for Agent Memory

### 7. KUHAPChatPage.tsx Fix Summary - COMPLETED ‚úÖ

**Problem**: Event streaming tidak berfungsi - tidak ada tool calls, memory updates, atau final response.

**Root Cause**: Oversimplified event handling yang hanya cover basic events.

**Solution Applied**: 
- Enhanced event handling dengan complete event coverage
- Proper citation parsing dan preservation
- Smart content merging strategy
- Comprehensive logging untuk debugging
- Graceful fallback untuk edge cases

**Results**:
- ‚úÖ Tool call animations bekerja
- ‚úÖ Memory update indicators berfungsi  
- ‚úÖ Citations ter-display dengan benar
- ‚úÖ Final responses selalu ada
- ‚úÖ Error handling yang robust

### 8. Mobile Responsiveness Fix for Header Elements - COMPLETED ‚úÖ

**Problem**: Header avatars, buttons, dan layout tidak responsive di mobile dengan ukuran yang tidak tepat.

**Root Cause**: Fixed sizes dan spacing yang tidak adaptive untuk different screen sizes.

**Solution Applied**:

#### Header Avatar Enhancement:
```typescript
// ‚úÖ AFTER: Responsive avatar dengan mobile-first approach
<div className="w-7 h-7 sm:w-8 sm:h-8 bg-orange-500 rounded-full flex items-center justify-center flex-shrink-0">
  <span className="text-white text-xs sm:text-sm font-semibold">HP</span>
</div>

// ‚úÖ Header layout dengan responsive spacing
<div className="flex items-center gap-2 sm:gap-3">
<div className="border-b border-gray-200 bg-white px-3 sm:px-4 py-2.5 sm:py-3">

// ‚úÖ Action buttons dengan proper mobile sizing
<Button className="text-gray-500 w-7 h-7 sm:w-10 sm:h-10">
  <Info className="h-4 w-4 sm:h-5 sm:w-5" />
</Button>
```

#### Header Layout Enhancement:
```typescript
// ‚úÖ Responsive gaps dan padding
<div className="flex items-center gap-2 sm:gap-3">
<div className="border-b border-gray-200 bg-white px-3 sm:px-4 py-2.5 sm:py-3">

// ‚úÖ Title truncation untuk prevent overflow
<div className="min-w-0">
  <h1 className="text-base sm:text-lg font-semibold text-gray-900 truncate">
  <p className="text-xs sm:text-sm text-gray-600 truncate">
</div>
```

#### Action Buttons Enhancement:
```typescript
// ‚úÖ Smaller buttons dan icons pada mobile
<Button className="text-gray-500 w-7 h-7 sm:w-10 sm:h-10">
  <Info className="h-4 w-4 sm:h-5 sm:w-5" />
</Button>
```

#### Container Spacing Enhancement:
```typescript
// ‚úÖ Responsive padding dan spacing
className="p-3 sm:p-4 m-2 sm:m-4"
className="space-y-4 sm:space-y-6"
className="gap-2 sm:gap-3"
```

**Benefits**:
- ‚úÖ **Mobile-First Design**: Smaller elements pada mobile, larger pada desktop
- ‚úÖ **Better Touch Targets**: Proper sizing untuk mobile interaction
- ‚úÖ **No Overflow**: Truncation prevents text overflow issues
- ‚úÖ **Consistent Spacing**: Responsive gaps dan padding
- ‚úÖ **Professional Appearance**: Clean layout across all devices
- ‚úÖ **Flex-Shrink Protection**: Avatars maintain size consistency

**Mobile Responsiveness Best Practices Applied**:
- **Progressive Enhancement**: Start mobile-first, enhance untuk desktop
- **Responsive Utilities**: `sm:` prefixes untuk desktop enhancements
- **Touch-Friendly**: Adequate button sizes untuk mobile touch
- **Content Protection**: `min-w-0` dan `truncate` untuk text overflow
- **Flexible Layouts**: Responsive spacing dan sizing

### 9. Desktop Scrolling Fix for Chat Layout Structure - COMPLETED ‚úÖ

**Problem**: KUHAPChatPage.tsx mengalami unwanted scrolling di desktop view karena layout structure yang tidak optimal.

**Root Cause**: 
- **Improper Container Nesting**: Chat container menggunakan `max-w-3xl mx-auto w-full` yang menyebabkan horizontal scroll
- **Complex Header Structure**: Header layout yang berlebihan dengan responsive spacing
- **Wrong Layout Hierarchy**: Tidak mengikuti pattern yang benar dari KUHPChatPage yang working

**Solution Applied**:

#### Layout Structure Fix:
```typescript
// ‚ùå BEFORE: Problematic layout dengan scroll issues
<div className="fixed inset-0 z-20 bg-white lg:pl-64 flex flex-col">
  <div className="border-b border-gray-200 bg-white px-3 sm:px-4 py-2.5 sm:py-3 flex items-center justify-between shadow-sm">
    {/* Complex responsive header */}
  </div>
  <div className="flex-1 overflow-y-auto p-3 sm:p-4 space-y-4 sm:space-y-6 max-w-3xl mx-auto w-full">
    {/* Chat content with max-width causing scroll */}
  </div>
</div>

// ‚úÖ AFTER: Clean layout structure without scroll
<div className="fixed inset-0 z-20 bg-white lg:pl-64 flex flex-col">
  <header className="flex items-center justify-between p-4 border-b border-gray-200 shadow-sm">
    {/* Simple header structure */}
  </header>
  <div className="flex-1 overflow-y-auto p-4 space-y-6">
    <div className="max-w-3xl mx-auto">
      {/* Chat content properly constrained */}
    </div>
  </div>
</div>
```

#### Header Simplification:
```typescript
// ‚úÖ Clean header structure
<header className="flex items-center justify-between p-4 border-b border-gray-200 shadow-sm">
  <div className="flex items-center gap-3">
    <Button variant="ghost" size="icon" className="rounded-full">
      <ArrowLeft className="h-5 w-5" />
    </Button>
    <div className="flex items-center gap-3">
      <div className="w-8 h-8 bg-orange-500 rounded-full flex items-center justify-center">
        <span className="text-white text-sm font-semibold">HP</span>
      </div>
      <div>
        <h1 className="font-semibold">Hukum Perdata AI</h1>
        <p className="text-sm text-gray-600 hidden sm:block">Konsultasi terkait hukum perdata</p>
      </div>
    </div>
  </div>
  <div className="flex items-center gap-2">
    {/* Action buttons */}
  </div>
</header>
```

#### Container Positioning Fix:
```typescript
// ‚úÖ Proper container hierarchy untuk prevent scroll
<div className="flex-1 overflow-y-auto p-4 space-y-6">
  <div className="max-w-3xl mx-auto">
    {/* All content properly wrapped */}
    {/* File validation, example questions, messages */}
  </div>
</div>

// ‚úÖ Input area dengan proper constraint
<div className="border-t border-gray-200 bg-white p-4">
  <div className="max-w-3xl mx-auto">
    {/* Input controls */}
  </div>
</div>
```

**Key Layout Principles Applied**:
- **Proper Container Nesting**: `max-w-3xl mx-auto` hanya di inner content, bukan main container
- **Simple Header Structure**: Menggunakan `<header>` semantic element dengan clean layout
- **Flex Layout Optimization**: Proper flex hierarchy untuk prevent overflow
- **Container Responsibility**: Each container has single responsibility
- **Content Constraint**: Max-width hanya applied di content level, not container level

**Benefits**:
- ‚úÖ **No Desktop Scroll**: Eliminates unwanted horizontal scrolling di desktop
- ‚úÖ **Clean Layout**: Professional structure yang consistent
- ‚úÖ **Better Performance**: Optimized rendering dengan proper container hierarchy
- ‚úÖ **Mobile Compatibility**: Layout remains responsive untuk all screen sizes
- ‚úÖ **Pattern Consistency**: Follows established working patterns dari KUHPChatPage
- ‚úÖ **Linter Errors Fixed**: Removed unused imports dan variables untuk clean code

**Pattern Guidelines untuk Chat Components**:
- **Never use `max-w-3xl mx-auto` di main chat container**: Apply hanya di inner content wrapper
- **Use semantic header element**: `<header>` untuk proper structure
- **Keep container hierarchy simple**: Avoid unnecessary nesting
- **Follow working patterns**: Reference KUHPChatPage structure untuk consistency
- **Test desktop scrolling**: Always verify no unwanted scroll di desktop view
- **Clean unused imports**: Remove unused imports untuk prevent linter errors

## Lessons
