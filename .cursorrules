# Instructions

During your interaction with the user, if you find anything reusable in this project (e.g. version of a library, model name), especially about a fix to a mistake you made or a correction you received, you should take note in the `Lessons` section in the `.cursorrules` file so you will not make the same mistake again. 

You should also use the `.cursorrules` file as a Scratchpad to organize your thoughts. Especially when you receive a new task, you should first review the content of the Scratchpad, clear old different task if necessary, first explain the task, and plan the steps you need to take to complete the task. You can use todo markers to indicate the progress, e.g.
[X] Task 1
[ ] Task 2

Also update the progress of the task in the Scratchpad when you finish a subtask.
Especially when you finished a milestone, it will help to improve your depth of task accomplishment to use the Scratchpad to reflect and plan.
The goal is to help you maintain a big picture as well as the progress of the task. Always refer to the Scratchpad when you plan the next step.

# Tools

Note all the tools are in python. So in the case you need to do batch processing, you can always consult the python files and write your own script.

## Screenshot Verification

The screenshot verification workflow allows you to capture screenshots of web pages and verify their appearance using LLMs. The following tools are available:

1. Screenshot Capture:
```bash
venv/bin/python tools/screenshot_utils.py URL [--output OUTPUT] [--width WIDTH] [--height HEIGHT]
```

2. LLM Verification with Images:
```bash
venv/bin/python tools/llm_api.py --prompt "Your verification question" --provider {openai|anthropic} --image path/to/screenshot.png
```

Example workflow:
```python
from screenshot_utils import take_screenshot_sync
from llm_api import query_llm

# Take a screenshot

screenshot_path = take_screenshot_sync('https://example.com', 'screenshot.png')

# Verify with LLM

response = query_llm(
    "What is the background color and title of this webpage?",
    provider="openai",  # or "anthropic"
    image_path=screenshot_path
)
print(response)
```

## LLM

You always have an LLM at your side to help you with the task. For simple tasks, you could invoke the LLM by running the following command:
```
venv/bin/python ./tools/llm_api.py --prompt "What is the capital of France?" --provider "anthropic"
```

The LLM API supports multiple providers:
- OpenAI (default, model: gpt-4o)
- Azure OpenAI (model: configured via AZURE_OPENAI_MODEL_DEPLOYMENT in .env file, defaults to gpt-4o-ms)
- DeepSeek (model: deepseek-chat)
- Anthropic (model: claude-3-sonnet-20240229)
- Gemini (model: gemini-pro)
- Local LLM (model: Qwen/Qwen2.5-32B-Instruct-AWQ)

But usually it's a better idea to check the content of the file and use the APIs in the `tools/llm_api.py` file to invoke the LLM if needed.

## Web browser

You could use the `tools/web_scraper.py` file to scrape the web.
```
venv/bin/python ./tools/web_scraper.py --max-concurrent 3 URL1 URL2 URL3
```
This will output the content of the web pages.

## Search engine

You could use the `tools/search_engine.py` file to search the web.
```
venv/bin/python ./tools/search_engine.py "your search keywords"
```
This will output the search results in the following format:
```
URL: https://example.com
Title: This is the title of the search result
Snippet: This is a snippet of the search result
```
If needed, you can further use the `web_scraper.py` file to scrape the web page content.

# Lessons

## User Specified Lessons

- You have a python venv in ./venv. Use it.
- Include info useful for debugging in the program output.
- Read the file before you try to edit it.
- Due to Cursor's limit, when you use `git` and `gh` and need to submit a multiline commit message, first write the message in a file, and then use `git commit -F <filename>` or similar command to commit. And then remove the file. Include "[Cursor] " in the commit message and PR title.

## Cursor learned

- For search results, ensure proper handling of different character encodings (UTF-8) for international queries
- Add debug information to stderr while keeping the main output clean in stdout for better pipeline integration
- When using seaborn styles in matplotlib, use 'seaborn-v0_8' instead of 'seaborn' as the style name due to recent seaborn version changes
- Use 'gpt-4o' as the model name for OpenAI's GPT-4 with vision capabilities

## API Integration Lessons

- When using FormData for file uploads, don't set Content-Type header manually - let browser handle it
- For api.reserse.id, always use VITE_API_KEY in X-API-Key header
- For flow.reserse.id, use VITE_PERKABA_API_KEY
- Set appropriate file size limits (50MB) for image uploads in nginx and vite config
- Use relative URLs with proxy in vite.config.ts instead of absolute URLs
- Add all required domains to allowedHosts in vite.config.ts (api.reserse.id, flow.reserse.id, app.reserse.id)
- Configure allowedHosts in both server and preview mode
- Use wildcard subdomain (.reserse.id) for broader access
- Set proper hostname in docker and nginx configs

## PenyidikAi Agent Implementation Pattern

Untuk menambahkan agen baru di PenyidikAi.tsx, ikuti langkah-langkah berikut:

1. Buat Service File (src/services/[agentName]Service.ts):
   - Import env dan uuid
   - Gunakan FormData untuk request body
   - Implementasikan retry logic untuk error jaringan dan server
   - Gunakan endpoint `/v1/playground/agents/[endpoint-name]/runs`
   - Implementasikan fungsi sendChatMessage, clearChatHistory, dan initializeSession
   - Contoh:
   ```typescript
   const formData = new FormData();
   formData.append('message', message.trim());
   formData.append('agent_id', 'fismondev-chat');
   formData.append('stream', 'false');
   formData.append('monitor', 'false');
   formData.append('session_id', currentSessionId);
   formData.append('user_id', currentSessionId);
   ```

2. Buat Konfigurasi Agen (src/data/agents/[agentName]Agent.ts):
   - Gunakan interface ExtendedAgent
   - Tentukan id, name, type, status, dan description
   - Tambahkan icon dan iconClassName
   - Contoh:
   ```typescript
   export const fismondevAgent: ExtendedAgent = {
     id: 'fismondev_001',
     name: 'Fismondev AI',
     type: 'fismondev_chat',
     status: 'on',
     description: 'Asisten AI yang fokus pada tindak pidana di bidang Fiskal, Moneter, dan Devisa',
     icon: DollarSign,
     iconClassName: 'text-green-600',
     fields: []
   };
   ```

3. Update Types (src/types/index.ts):
   - Tambahkan tipe agen baru ke union type AgentType
   - Contoh: `| 'fismondev_chat'`

4. Update Utils (src/utils/utils.ts):
   - Tambahkan ID agen ke AGENT_IDS
   - Tambahkan case di getAgentTypeFromId
   - Contoh:
   ```typescript
   FISMONDEV_CHAT: 'fismondev_001'
   ```

5. Update AgentCard (src/components/AgentCard.tsx):
   - Tambahkan case di getAgentIcon
   - Gunakan ikon yang sesuai
   - Contoh:
   ```typescript
   case 'fismondev_chat':
     return <img src="/img/krimsus.png" alt="Fismondev AI" className="h-10 w-10" />;
   ```

6. Update PenyidikAi Component (src/pages/PenyidikAi.tsx):
   - Import agen dan service
   - Tambahkan agen ke array agents
   - Tambahkan case di renderContent
   - Tambahkan styling yang sesuai
   - Contoh:
   ```typescript
   case 'fismondev_chat':
     return <ChatInterface sendMessage={sendFismondevChatMessage} />;
   ```

7. Styling Konsisten:
   - Gunakan gradient yang sesuai dengan jenis agen
   - Pertahankan konsistensi visual dengan agen lain
   - Contoh:
   ```typescript
   agent.type === 'fismondev_chat'
     ? "bg-gradient-to-br from-green-50 to-emerald-50 hover:from-green-100 hover:to-emerald-100"
     : "bg-gradient-to-br from-purple-50 to-indigo-50 hover:from-purple-100 hover:to-indigo-100"
   ```

## Security Lessons

- Add rate limiting in nginx (10r/s with burst 20)
- Block unnecessary paths (/webui, /geoserver, /admin, etc.)
- Add security headers (X-Frame-Options, X-Content-Type-Options, X-XSS-Protection)
- Configure robots.txt to disallow all
- Handle favicon.ico and .git requests properly
- Filter proxy paths in vite.config.ts to only allow needed routes

## Project Structure Lessons

From project.md:
- Follow consistent service pattern for new agents:
  - Service file in src/services/
  - Agent config in src/data/agents/
  - Page component in src/pages/
  - Update Sidebar.tsx and App.tsx
- Use existing components:
  - ChatInterface for chat functionality
  - AgentCard for agent display
  - BaseAgentForm for forms
- Maintain consistent styling with Tailwind CSS
- Handle chat message formatting:
  - Use flex-wrap and min-w-0 to prevent overflow
  - Add pre-wrap for code blocks and pre elements
  - Make tables scrollable horizontally
  - Use word-break and overflow-wrap for long content
- Agent configuration best practices:
  - Add descriptive icons that match agent functionality
  - Use consistent color schemes for related agents
  - Keep form heights appropriate for expected input length
  - Include clear placeholder text in form fields

## Chat Agent Implementation Pattern

When adding a new chat-based agent to the UndangUndang component, follow these steps:

1. Create Service File (src/services/[agentName]Service.ts):
 - Import env config and uuid
 - Configure API constants (API_KEY, MAX_RETRIES, etc.)
 - Implement session management
 - Implement parseResponse function for handling responses
 - Implement sendChatMessage with FormData and proper error handling
 - Add clearChatHistory and initializeSession functions

2. Update Types (src/types/index.ts):
 - Add new agent type to AgentType union (e.g., 'ciptakerja_chat')

3. Update Utils (src/utils/utils.ts):
 - Add agent ID to AGENT_IDS constant
 - Add case in getAgentTypeFromId
 - Don't add to getTypeDisplay if it's a chat agent (these use custom display names)

4. Update Agent Card (src/components/AgentCard.tsx):
 - Add case in getAgentIcon with appropriate Lucide icon
 - Choose an icon that represents the agent's function
 - Use consistent icon size (24px)
 - Give icon an appropriate color

5. Update UndangUndang Component (src/pages/UndangUndang.tsx):
 - Import new service's sendChatMessage
 - Add agent to agents array with proper configuration
 - Add case in renderContent switch statement
 - Configure card styling:
   * Use professional color gradients
   * Maintain visual hierarchy
   * Ensure contrast and readability
   * Keep consistent hover effects
   * Match icon and colors to agent's purpose

6. Follow Best Practices:
 - Maintain consistent error handling
 - Use proper session management
 - Implement proper logging
 - Follow API security guidelines
 - Use professional color schemes appropriate for police applications
 - Ensure visual consistency with existing agents

Professional Color Scheme Examples:
- Financial Services (P2SK): blue-indigo gradient (from-blue-50 to-indigo-50)
- Criminal Law (KUHP): rose-orange gradient (from-rose-50 to-orange-50)
- Technology Law (ITE): cyan-sky gradient (from-cyan-50 to-sky-50)
- Labor Law (Cipta Kerja): slate-gray gradient (from-slate-50 to-gray-50)

## Environment Configuration Lessons

- Use default values in env.ts for critical variables
- Keep API keys secure and never log them
- Use separate keys for different services:
  - VITE_API_KEY for api.reserse.id
  - VITE_PERKABA_API_KEY for flow.reserse.id
  - VITE_OPENAI_API_KEY for OpenAI
  - etc.

## Performance Optimization Lessons

- Use code splitting with manual chunks for vendor, UI, and feature code
- Enable proper caching headers in nginx for static assets
- Configure gzip compression for text-based assets
- Preload critical assets in index.html
- Use resource hints (preconnect) for external APIs
- Optimize build settings in vite.config.ts
- Use immutable cache for versioned assets
- Disable caching for API endpoints while keeping static asset caching
- Use different cache strategies for different content types
- Keep HTTP/2 benefits without affecting API responses

## Docker Deployment Lessons

- Use multi-stage builds to reduce final image size
- Configure proper healthchecks for container monitoring
- Set resource limits to prevent container abuse
- Use nginx:alpine as production base image
- Enable logging rotation to prevent disk space issues
- Configure Docker networks with specific names and gateways
- Clean up unused networks before redeploying
- Use production-specific nginx configuration
- Use npm ci for faster, reliable builds
- Enable nginx caching for static assets
- Configure proper resource limits for production
- Use HTTP/2 for better performance
- Enable brotli compression for better compression ratios

## UI/UX Lessons

- Handle chat interface layout:
  - Use flex-wrap and min-w-0 for message containers to prevent overflow
  - Avoid nested scrollbars by using whitespace-pre-wrap and break-words
  - Use single scrollable container at the top level with proper bottom padding (pb-32)
  - Keep input area fixed at bottom with position: fixed
  - Let content flow naturally with proper word breaking
  - Keep tables and code blocks within container width
  - Use space-y utilities for consistent message spacing
  - Ensure enough bottom padding to prevent content from being hidden under input area
- Consider different AI response formats:
  - Code blocks
  - Tables
  - Long URLs
  - Formatted text
  - Lists and indentation
- Add chat-message class for consistent styling across components
- Use TypeScript interfaces for better type safety and documentation
- Remove unused imports to improve code cleanliness
- Visual consistency:
  - Use meaningful icons for each agent type
  - Maintain consistent color schemes
  - Adjust form sizes based on expected content
  - Provide clear visual hierarchy
- Agent icon implementation:
  - Icons should be defined in AgentCard.tsx's getAgentIcon function
  - Use Lucide icons consistently across all agents
  - Follow color scheme patterns (e.g., indigo for analytics, blue for research)
  - Keep icon size consistent (24px)
  - Don't define icons in individual agent files
  - Use proper icon that represents agent's function (e.g., BarChart3 for trend analysis)
  - For custom SVG icons:
    * Place SVG files in public/img directory
    * Reference in img src with absolute path from public (e.g., "/img/google-scholar.svg")
    * Keep original SVG colors if they match the design
    * Maintain consistent size with w-6 h-6 classes (24px)
- ChatPage implementation best practices:
  - Use consistent structure across all ChatPage components
  - Follow the same pattern for message handling, formatting, and display
  - Use conditional rendering for UI elements that should appear/disappear based on state
  - Hide example questions after user starts chatting (messages.length > 1)
  - Use proper spacing and layout for different screen sizes
  - Ensure proper sidebar spacing with lg:pl-64 to prevent overlap
  - Use max-w-3xl mx-auto for content centering
  - Implement proper scrolling behavior with requestAnimationFrame
  - Use consistent styling for message bubbles, info panels, and input areas
  - Provide clear visual feedback for user actions (copying, sending messages)
  - Use aria-label attributes for better accessibility
  - Remove unused imports to prevent TypeScript errors
- UndangUndang ChatPage implementation pattern:
  - Create dedicated ChatPage components for each agent type (e.g., KUHPChatPage)
  - Use consistent color schemes that match the agent's domain:
    * KUHP (Criminal Law): rose-600 (red) theme
    * P2SK (Financial Services): blue-600 (blue) theme
    * ITE (Technology Law): cyan-600 (light blue) theme
    * Cipta Kerja (Labor Law): slate-600 (gray) theme
    * Kesehatan (Health Law): emerald-600 (green) theme
    * Fidusia (Insurance Law): orange-600 (orange) theme
  - Customize welcome messages and example questions for each agent's domain
  - Maintain consistent UI structure across all ChatPage components
  - Use the same formatMessage function for consistent markdown rendering
  - Implement proper session management with initializeSession and clearChatHistory
  - Use consistent error handling and loading states

### File Upload Implementation Patterns

1. State Management untuk File Upload:
   ```typescript
   // State untuk tracking file
   const [selectedFiles, setSelectedFiles] = useState<File[]>([]);
   // State untuk progress
   const [progress, setProgress] = useState<{status: string, percent: number}>({
     status: 'preparing',
     percent: 0
   });
   const [showProgress, setShowProgress] = useState(false);
   ```

2. Implementasi File Input dan Handler:
   ```typescript
   // Ref untuk input file yang disembunyikan
   const fileInputRef = useRef<HTMLInputElement>(null);
   
   // Handler untuk perubahan file
   const handleFileChange = (e: React.ChangeEvent<HTMLInputElement>) => {
     if (e.target.files) {
       const filesArray = Array.from(e.target.files);
       setSelectedFiles(prev => [...prev, ...filesArray]);
     }
   };
   
   // Handler untuk menghapus file
   const handleRemoveFile = (indexToRemove: number) => {
     setSelectedFiles(prev => prev.filter((_, index) => index !== indexToRemove));
   };
   
   // Fungsi untuk membuka dialog file
   const handleOpenFileDialog = () => {
     if (fileInputRef.current) {
       fileInputRef.current.click();
     }
   };
   ```

3. Komponen Progress Bar:
   ```typescript
   // Progress bar component
   const ProgressBar = ({ percent = 0, status = 'uploading' }) => {
     const getStatusText = () => {
       switch (status) {
         case 'preparing': return 'Mempersiapkan...';
         case 'uploading': return 'Mengunggah file...';
         case 'processing': return 'Memproses dokumen...';
         case 'completed': return 'Selesai!';
         default: return 'Memproses...';
       }
     };
     
     const getColor = () => {
       switch (status) {
         case 'completed': return 'bg-green-500';
         case 'processing': return 'bg-blue-500';
         case 'uploading': return 'bg-amber-500';
         default: return 'bg-blue-500';
       }
     };
     
     return (
       <div className="w-full mb-3">
         <div className="flex justify-between items-center mb-1">
           <span className="text-sm font-medium text-gray-700">{getStatusText()}</span>
           <span className="text-sm font-medium text-gray-700">{percent}%</span>
         </div>
         <div className="w-full bg-gray-200 rounded-full h-2.5">
           <div 
             className={`h-2.5 rounded-full ${getColor()} transition-all duration-500 ease-in-out`} 
             style={{ width: `${percent}%` }}
           ></div>
         </div>
       </div>
     );
   };
   ```

4. UI Elements untuk File Upload:
   ```typescript
   {/* File Upload Button */}
   <button
     type="button"
     onClick={handleOpenFileDialog}
     disabled={isProcessing}
     className="absolute left-2 bottom-3 p-2 rounded-lg text-gray-500 hover:text-blue-500 hover:bg-blue-50 transition-colors z-20"
     aria-label="Upload file"
   >
     <Paperclip className="w-5 h-5" />
   </button>
   
   {/* Hidden file input */}
   <input 
     type="file" 
     ref={fileInputRef}
     onChange={handleFileChange}
     className="hidden"
     multiple
     accept=".pdf,.doc,.docx,.txt,.csv,.xls,.xlsx,.jpg,.jpeg,.png"
   />
   
   {/* File Preview Area */}
   {selectedFiles.length > 0 && (
     <div className="mb-3 flex flex-wrap gap-2">
       {selectedFiles.map((file, index) => (
         <div 
           key={index}
           className="bg-blue-50 border border-blue-200 rounded-lg px-3 py-1 flex items-center gap-2 text-sm text-blue-700"
         >
           <File className="w-4 h-4" />
           <span className="truncate max-w-[150px]">{file.name}</span>
           <button 
             onClick={() => handleRemoveFile(index)}
             className="text-blue-500 hover:text-blue-700"
             aria-label="Hapus file"
           >
             <XIcon className="w-4 h-4" />
           </button>
         </div>
       ))}
     </div>
   )}
   
   {/* Progress Bar UI */}
   {showProgress && (
     <div className="bg-white border border-gray-200 rounded-xl p-4 mb-4 shadow-sm">
       <ProgressBar 
         percent={progress.percent} 
         status={progress.status}
       />
       <p className="text-xs text-gray-500 italic">
         {progress.status === 'uploading' 
           ? 'Mengunggah file besar memerlukan waktu, mohon jangan refresh halaman.' 
           : progress.status === 'processing'
           ? 'AI sedang menganalisis dokumen, proses ini mungkin memerlukan beberapa menit untuk file besar.'
           : 'Sedang memproses...'}
       </p>
     </div>
   )}
   ```

5. Integrasi dengan Progress API:
   ```typescript
   // Setup progress listener
   useEffect(() => {
     const unsubscribe = onProgress((progressInfo) => {
       setProgress({
         status: progressInfo.status,
         percent: progressInfo.percent || 0
       });
       
       if (progressInfo.status === 'completed') {
         // Hide progress after completion + delay
         setTimeout(() => {
           setShowProgress(false);
         }, 1000);
       } else {
         setShowProgress(true);
       }
     });
     
     return () => {
       unsubscribe();
     };
   }, []);
   ```

6. File Size Checking:
   ```typescript
   // Check if any file is large (> 5MB)
   const hasLargeFile = selectedFiles.some(file => file.size > 5 * 1024 * 1024);
   if (hasLargeFile) {
     setShowProgress(true);
   }
   
   // Log file sizes sebelum upload
   if (selectedFiles.length > 0) {
     console.log('Uploading files:');
     selectedFiles.forEach((file, index) => {
       console.log(`File ${index + 1}: ${file.name} - ${(file.size / 1024 / 1024).toFixed(2)}MB`);
     });
   }
   ```

7. Error Handling untuk Upload File:
   ```typescript
   // Fungsi untuk menampilkan error yang lebih spesifik
   const getErrorMessage = (error: any): string => {
     if (!navigator.onLine) {
       return 'Perangkat Anda sedang offline. Silakan periksa koneksi internet dan coba lagi.';
     }
     
     if (error.message) {
       // Jika error spesifik tentang ukuran file
       if (error.message.includes('File terlalu besar')) {
         return 'File terlalu besar. Harap gunakan file dengan ukuran lebih kecil (maksimal 50MB).';
       }
       
       // Jika error timeout
       if (error.message.includes('timeout') || error.message.includes('timed out')) {
         return 'Permintaan timeout. File mungkin terlalu besar atau koneksi terlalu lambat.';
       }
       
       // Jika error spesifik tentang rate limit
       if (error.message.includes('Terlalu banyak permintaan')) {
         return 'Terlalu banyak permintaan dalam waktu singkat. Silakan tunggu beberapa saat dan coba lagi.';
       }
       
       // Jika ada pesan error spesifik lainnya, tampilkan
       return error.message;
     }
     
     // Default error message
     return 'Permintaan Terlalu banyak, coba lagi dalam 2 menit. (dengan bertumbuhnya pengguna, saat ini kami membatasi permintaan untuk menjaga kualitas layanan)';
   };
   ```

8. Best Practices untuk File Upload:
   - Gunakan accept attribute untuk membatasi jenis file yang dapat diunggah
   - Tampilkan progress bar khususnya untuk file besar
   - Berikan feedback visual untuk status upload (warna berbeda untuk status berbeda)
   - Tampilkan pesan informatif selama proses upload
   - Implementasikan mekanisme untuk menghapus file sebelum upload
   - Truncate nama file yang terlalu panjang dengan class `truncate max-w-[150px]`
   - Log ukuran file untuk debugging
   - Nonaktifkan tombol upload selama proses upload
   - Berikan pesan error yang spesifik untuk masalah umum (file terlalu besar, timeout, offline)
   - Reset selectedFiles setelah upload berhasil

9. Integrasi dengan Form Submission:
   ```typescript
   // Tetap memungkinkan submit jika ada file yang dipilih, bahkan jika inputMessage kosong
   if ((selectedFiles.length === 0 && !inputMessage.trim()) || isProcessing) return;
   
   // Jika pesan kosong tapi ada file, tampilkan pesan default
   content: inputMessage.trim() || (selectedFiles.length > 0 ? "Tolong analisis file yang saya kirimkan." : ""),
   
   // Kirim pesan dengan file jika ada
   const response = await sendChatMessage(
     userMessage.content, 
     selectedFiles.length > 0 ? selectedFiles : undefined
   );
   
   // Reset selected files setelah berhasil mengirim
   setSelectedFiles([]);
   setShowProgress(false);
   ```

# Scratchpad

Current Task: Menerapkan Welcome Message Baru di Multiple Chat Pages

[X] Mengubah Welcome Message dan Logo di SiberChatPage.tsx
[X] Menerapkan teknik yang sama di TipidkorChatPage.tsx
[X] Menerapkan teknik yang sama di IndagsiChatPage.tsx
[X] Menerapkan teknik yang sama di FismondevChatPage.tsx
[X] Mendokumentasikan perubahan di .cursorrules

## Langkah-langkah Menerapkan Welcome Message Baru di Multiple Chat Pages

1. Mengubah Welcome Message di Setiap File:
   [X] Mengganti pesan selamat datang dengan string kosong untuk memicu tampilan welcome UI baru
   ```typescript
   // Set empty welcome message to trigger welcome UI
   setMessages([
     {
       content: '',
       type: 'bot',
       timestamp: new Date(),
     },
   ]);
   ```

2. Membuat Komponen Welcome Message Baru di Setiap File:
   [X] Menambahkan komponen welcome message dengan tulisan nama AI di tengah
   [X] Menyesuaikan warna dengan tema masing-masing AI:
      - SIBER AI: Biru (blue-600)
      - TIPIDKOR AI: Merah (red-600)
      - INDAGSI AI: Ungu (purple-600)
      - FISMONDEV AI: Hijau (green-600)
   ```jsx
   {/* Welcome Message - Bold AI NAME in center */}
   {messages.length <= 1 && (
     <div className="flex flex-col items-center justify-center h-[50vh] text-center">
       <div className="w-20 h-20 bg-[color]-100 rounded-full flex items-center justify-center mb-4">
         <img 
           src="/img/krimsus.png"
           alt="Krimsus"
           className="w-16 h-16 object-contain"
         />
       </div>
       <h1 className="text-4xl font-bold text-[color]-600 mb-4">[AI NAME]</h1>
       <p className="text-gray-600 max-w-md">
         Asisten untuk membantu Anda dengan pertanyaan seputar [domain].
       </p>
     </div>
   )}
   ```

3. Menambahkan Kondisi untuk Menampilkan Pesan di Setiap File:
   [X] Menambahkan kondisi untuk hanya menampilkan pesan yang memiliki konten
   ```jsx
   {messages.map((message, index) => (
     message.content && (
       <div>
         {/* Message content */}
       </div>
     )
   ))}
   ```

## Hasil Perubahan

1. Tampilan Welcome Message yang Konsisten:
   - Semua chat page sekarang memiliki tampilan welcome message yang konsisten
   - Setiap AI memiliki warna tema yang sesuai dengan domainnya
   - Tampilan welcome message otomatis menghilang saat chat dimulai

2. Peningkatan UX:
   - Pesan kosong tidak ditampilkan di chat
   - Tampilan lebih profesional dan modern
   - Fokus pada nama AI yang ditampilkan secara menonjol

3. Konsistensi Visual:
   - SIBER AI: Tema biru untuk kejahatan siber
   - TIPIDKOR AI: Tema merah untuk tindak pidana korupsi
   - INDAGSI AI: Tema ungu untuk industri dan perdagangan
   - FISMONDEV AI: Tema hijau untuk fiskal, moneter, dan devisa

## Pembelajaran

1. Penggunaan Conditional Rendering yang Konsisten:
   - Gunakan `messages.length <= 1` untuk menampilkan welcome message hanya di awal
   - Gunakan `message.content &&` untuk memfilter pesan kosong

2. Penerapan Tema Warna yang Sesuai:
   - Sesuaikan warna dengan domain masing-masing AI
   - Gunakan kombinasi warna yang kontras untuk meningkatkan keterbacaan

3. Reusable Pattern:
   - Pola yang sama dapat diterapkan ke berbagai chat interface
   - Hanya perlu menyesuaikan warna, logo, dan teks deskripsi

4. Optimasi Performa:
   - Gunakan string kosong untuk pesan awal daripada menghapus pesan sepenuhnya
   - Pertahankan struktur data yang konsisten untuk mencegah re-render yang tidak perlu

Refleksi:
- Perubahan welcome message memberikan identitas visual yang lebih kuat untuk setiap AI
- Penggunaan logo yang konsisten menciptakan konsistensi visual dengan identitas institusi
- Tampilan welcome message yang menonjol memberikan kesan profesional dan modern
- Pendekatan ini berhasil diterapkan ke berbagai chat interface dengan penyesuaian minimal

## PenyidikAi Agent Implementation Pattern (Narkotika AI)

Menambahkan agen chat baru ke Penyidik AI mengikuti pola yang sama dengan agen sebelumnya (Fismondev, Siber, dll). Langkah-langkah spesifik untuk Narkotika AI:

1.  **Service File (`src/services/narkotikaService.ts`)**: Duplikasi dari service yang ada (`siberService.ts`), ubah endpoint API ke `narkotika-chat`, dan sesuaikan log identifier (e.g., `NARKOTIKA: ...`).
2.  **Agent Configuration (`src/data/agents/narkotikaAgent.ts`)**: Buat file baru, gunakan interface `ExtendedAgent`, definisikan ID unik (`narkotika_001`), nama ("Narkotika AI"), tipe (`narkotika_chat`), deskripsi yang relevan, dan ikon (misalnya `Pill` dari Lucide) dengan kelas warna yang sesuai (`text-amber-600`).
3.  **Types (`src/types/index.ts`)**: Tambahkan `'narkotika_chat'` ke union type `AgentType`.
4.  **Utils (`src/utils/utils.ts`)**: Tambahkan konstanta ID (`NARKOTIKA_CHAT: 'narkotika_001'`) ke `AGENT_IDS` dan tambahkan `case AGENT_IDS.NARKOTIKA_CHAT: return 'narkotika_chat';` ke fungsi `getAgentTypeFromId`.
5.  **Agent Card (`src/components/AgentCard.tsx`)**: Tambahkan `case 'narkotika_chat':` ke fungsi `getAgentIcon` untuk menampilkan ikon yang sesuai (misalnya `<img src="/img/krimsus.png" alt="Narkotika AI" ... />`).
6.  **Chat Page Component (`src/components/ui/NarkotikaChatPage.tsx`)**: Duplikasi dari komponen chat page yang ada (misalnya `PerkabaChatPage.tsx`), impor service dan hooks yang benar (`narkotikaService`), sesuaikan nama komponen, props, judul header, teks info panel, warna tema (amber), contoh pertanyaan, dan teks disclaimer agar sesuai dengan domain narkotika.
7.  **Main Page (`src/pages/PenyidikAi.tsx`)**: Impor konfigurasi agen (`narkotikaAgent`) dan komponen chat page (`NarkotikaChatPage`), tambahkan data agen ke array `agents` dengan warna yang sesuai ('amber'), dan tambahkan `case 'narkotika_chat':` ke fungsi `renderContent` untuk merender komponen `NarkotikaChatPage`.

## UI/UX Lessons (PenyidikAi)

### Chat Interface Textarea UX Improvement (Mobile)

Untuk meningkatkan pengalaman pengguna textarea input pada perangkat mobile di halaman chat:

1.  **Nonaktifkan Submit on Enter (Mobile)**: Hapus atau komentari logika dalam `handleKeyDown` yang memicu `handleSubmit` saat tombol Enter (tanpa Shift) ditekan. Ini memastikan Enter di keyboard mobile berfungsi sebagai pembuat baris baru.
    ```typescript
    const handleKeyDown = (_e: React.KeyboardEvent<HTMLTextAreaElement>) => {
      // Remove Enter key submission for mobile compatibility
      // Submission is handled by the Send button
      // if (_e.key === 'Enter' && !_e.shiftKey) {
      //   _e.preventDefault();
      //   handleSubmit();
      // }
    };
    ```
2.  **Implementasi Tinggi Textarea Dinamis**: Modifikasi `handleInputChange` untuk secara otomatis menyesuaikan tinggi textarea berdasarkan konten. Gunakan `rows={1}` pada komponen `Textarea` dan hapus `min-h-*` agar dimulai dari tinggi minimal. Tambahkan `overflow-y-auto`.
    ```typescript
    const handleInputChange = (e: React.ChangeEvent<HTMLTextAreaElement>) => {
      setInputMessage(e.target.value);
      // Adjust height dynamically
      const textarea = e.target;
      textarea.style.height = 'auto'; // Reset height
      textarea.style.height = `${textarea.scrollHeight}px`; // Set to scroll height
    };
    ```
    ```jsx
    <Textarea
      ref={textareaRef}
      rows={1} // Start with one row
      value={inputMessage}
      onChange={handleInputChange}
      onKeyDown={handleKeyDown}
      placeholder="Ketik pesan Anda..."
      className="resize-none pr-12 py-3 max-h-[200px] rounded-xl ... overflow-y-auto"
      disabled={isProcessing}
    />
    ```
3.  **Reset Tinggi Textarea Setelah Submit**: Tambahkan logika di `handleSubmit` untuk mereset tinggi textarea ke 'auto' setelah input dikosongkan (`setInputMessage('')`). Ini memastikan textarea kembali ke ukuran awal setelah pesan dikirim.
    ```typescript
    const handleSubmit = async () => {
      // ... (kode lainnya)

      setMessages((prev) => [...prev, userMessage]);
      setInputMessage('');
      // Reset textarea height after clearing input
      if (textareaRef.current) {
        textareaRef.current.style.height = 'auto';
      }
      setIsProcessing(true);
      // ... (rest of the function)
    };
    ```
4.  **Konsistensi**: Terapkan perubahan ini secara konsisten di semua komponen Chat Page (misalnya `IndagsiChatPage.tsx`, `NarkotikaChatPage.tsx`, dll.).

# Scratchpad

[X] Task: Menerapkan Welcome Message Baru di Multiple Chat Pages
[X] Task: Membuat Agen Narkotika AI baru
[X] Task: Meningkatkan UX Textarea Input Mobile
[X] Task: Mendokumentasikan perubahan di .cursorrules
[X] Task: Perbaikan textarea input pada mobile devices di SiberChatPage.tsx

## Progress dan Milestone Textarea Mobile UI

Perbaikan yang telah dilakukan:
1. Menambahkan atribut readOnly={false} secara eksplisit
2. Menambahkan autoComplete="off" untuk mencegah masalah autofill
3. Menambahkan focus pada komponen mount dengan setTimeout (500ms)
4. Memperbaiki z-index untuk textarea (z-10) dan tombol (z-20)
5. Mengubah posisi tombol dari bottom-2 menjadi bottom-3
6. Menonaktifkan submit on Enter untuk kompatibilitas mobile
7. Menambahkan type="button" pada tombol untuk mencegah form submission
8. Implementasi penyesuaian tinggi textarea secara dinamis

Hasil:
- Keyboard virtual sekarang muncul dengan baik di perangkat mobile
- Tombol dapat diklik tanpa masalah
- Tidak ada overlap antara elemen UI
- Tinggi textarea menyesuaikan dengan konten secara otomatis
- UX yang lebih baik untuk pengguna mobile

## Progress Implementasi File Upload

Fitur yang telah diimplementasikan:
1. Upload dan preview beragam jenis file (.pdf, .doc, .docx, .txt, .csv, .xls, .xlsx, .jpg, .jpeg, .png)
2. Tampilan progress bar dengan status yang berbeda (preparing, uploading, processing, completed)
3. Kemampuan untuk menghapus file sebelum dikirim
4. Deteksi file besar (>5MB) untuk menampilkan progress bar secara otomatis
5. Pesan informatif sesuai dengan tahap upload (uploading, processing)
6. Error handling spesifik untuk masalah umum dalam file upload
7. Multiple file upload support
8. Integrasi dengan form message (bisa kirim pesan dengan atau tanpa file)

Hasil:
- Interface yang user-friendly untuk upload file
- Feedback visual yang jelas selama proses upload
- Error messages yang lebih informatif
- Integrasi mulus dengan chat interface
- Support untuk berbagai jenis file yang relevan

## Firebase Implementation Lessons

### Authentication Best Practices

- Gunakan `AuthContext` sebagai single source of truth untuk state autentikasi
- Implementasikan loading state selama proses auth initialization untuk mencegah flash content
- Implementasikan ProtectedRoute untuk mencegah akses ke halaman tertentu tanpa login
- Gunakan atribut `referrerPolicy="no-referrer"` pada tag img saat menampilkan photoURL dari Google untuk menghindari masalah CORS
- Implementasikan error handling untuk avatar yang gagal dimuat dengan fallback ke inisial
- Gunakan `onAuthStateChanged` sebagai source of truth dibanding menyimpan state user secara manual

### User Management

- Saat mengubah email, selalu lakukan re-otentikasi terlebih dahulu:
  ```typescript
  const credential = EmailAuthProvider.credential(currentUser.email!, currentPassword);
  await reauthenticateWithCredential(currentUser, credential);
  await updateEmail(currentUser, email);
  ```
- Saat mengubah password, selalu validasi:
  1. Password baru dan konfirmasi cocok
  2. Password memenuhi kriteria keamanan (min 6 karakter)
  3. User telah melakukan re-otentikasi

- Gunakan state untuk menampilkan pesan error/success yang spesifik
  ```typescript
  setMessage({ 
    type: 'error', 
    text: error.code === 'auth/wrong-password'
      ? 'Password saat ini salah'
      : error.code === 'auth/requires-recent-login'
      ? 'Silakan login ulang untuk melakukan perubahan ini'
      : 'Gagal mengubah password'
  });
  ```

### Profile Display

- Untuk menampilkan foto profil dari Google:
  - Selalu gunakan handler error untuk fallback ke tampilan alternatif
  - Tambahkan atribut `referrerPolicy="no-referrer"` untuk mencegah masalah CORS
  - Tambahkan class `object-cover` untuk memastikan gambar pas dengan container
  - Reset error state saat user berubah

- Jika tidak ada foto profil, generate inisial dari nama:
  ```typescript
  const getInitials = () => {
    if (!currentUser?.displayName) return 'U';
    return currentUser.displayName
      .split(' ')
      .map(name => name[0])
      .join('')
      .toUpperCase()
      .substring(0, 2);
  };
  ```

### Form Validation

- Validasi form di client side sebelum mengirim ke Firebase
- Tampilkan pesan error yang spesifik berdasarkan Firebase error code
- Nonaktifkan tombol submit selama proses loading
- Reset form setelah submit berhasil

### Security

- Jangan simpan token Firebase di localStorage, gunakan mekanisme cookie yang secure
- Gunakan environment variables untuk menyimpan Firebase config
- Implementasikan validasi di sisi server melalui Firebase Rules
- Jangan menggunakan `console.log` untuk informasi sensitif seperti error authentication yang lengkap
- Gunakan timeout yang sesuai untuk operasi Firebase

### Firestore Session Management

- Hindari menyimpan nilai `undefined` ke dokumen Firestore:
  ```typescript
  // SALAH
  await setDoc(docRef, {
    field: data.value || undefined // Error: Unsupported field value: undefined
  });
  
  // BENAR - Pendekatan 1: Gunakan objek update
  const updateData = { timestamp: Timestamp.now() };
  if (data.value) updateData.field = data.value;
  await setDoc(docRef, updateData);
  
  // BENAR - Pendekatan 2: Gunakan conditional object spread
  await setDoc(docRef, {
    timestamp: Timestamp.now(),
    ...(data.value ? { field: data.value } : {})
  });
  ```

- Implementasikan mekanisme fallback untuk offline mode:
  ```typescript
  // Cek ketersediaan Firestore dan gunakan fallback ID jika tidak tersedia
  const firestoreAvailable = await checkFirestoreConnection().catch(() => false);
  if (!firestoreAvailable) {
    console.warn('Firestore not available, using local session mode');
    return `offline_${uuidv4()}`;
  }
  ```

- Gunakan soft delete untuk menghapus sesi alih-alih hard delete:
  ```typescript
  // Tandai sesi sebagai dihapus (soft delete)
  await setDoc(sessionRef, { 
    deleted: true,
    deletedAt: Timestamp.now()
  }, { merge: true });
  ```

- Validasi kepemilikan dokumen sebelum operasi:
  ```typescript
  // Validasi bahwa sesi ini milik user
  const sessionDoc = await getDoc(sessionRef);
  if (!sessionDoc.exists() || sessionDoc.data().userId !== auth.currentUser.uid) {
    throw new Error('Sesi tidak valid');
  }
  ```

- Gunakan `onSnapshot` untuk sinkronisasi realtime sesi di beberapa perangkat

- Implementasikan `checkFirestoreConnection` untuk verifikasi koneksi sebelum operasi database:
  ```typescript
  export const checkFirestoreConnection = async (): Promise<boolean> => {
    try {
      const testRef = doc(db, '_connection_test', 'test');
      await setDoc(testRef, { timestamp: serverTimestamp() }, { merge: true });
      return true;
    } catch (error) {
      console.error('Firestore connection error:', error);
      return false;
    }
  };
  ```

- Gunakan firestore path yang konsisten untuk struktur data:
  - `/users/{userId}` untuk data dan preferensi pengguna
  - `/sessions/{sessionId}` untuk menyimpan metadata sesi
  - `/sessions/{sessionId}/messages/{messageId}` untuk pesan dalam sesi

- Gunakan kueri compound untuk pengambilan sesi:
  ```typescript
  const q = query(
    sessionsRef, 
    where('userId', '==', userId),
    where('agentType', '==', 'agent-type'),
    orderBy('updatedAt', 'desc')
  );
  ```
